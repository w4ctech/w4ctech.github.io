(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{315:function(e,r,n){"use strict";n.r(r);var t=n(17),o=Object(t.a)({},(function(){var e=this,r=e.$createElement,n=e._self._c||r;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h4",{attrs:{id:"使用步骤"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用步骤","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用步骤")]),e._v(" "),n("blockquote",[n("p",[e._v("build.gradle引入依赖")])]),e._v(" "),n("pre",[n("code",[e._v("compile 'io.reactivex:rxjava:1.0.14' \ncompile 'io.reactivex:rxandroid:1.0.1' \n")])]),e._v(" "),n("h4",{attrs:{id:"创建数据源（被观察者-可观察者），泛型必须是object的子类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建数据源（被观察者-可观察者），泛型必须是object的子类","aria-hidden":"true"}},[e._v("#")]),e._v(" 创建数据源（被观察者/可观察者），泛型必须是Object的子类")]),e._v(" "),n("pre",[n("code",[e._v('Observable observable = Observable.create(new Observable.OnSubscribe<String>() {\n\t\n\t//事件源，可以指定\n\t@Override\n\tpublic void call(Subscriber<? super String> subscriber) {\n\t\t//执行多次\n\t\tsubscriber.onNext("第一次执行");\n\t\tsubscriber.onNext("第二次执行");\n\t\t//标记事件结束\n\t\tsubscriber.onCompleted();\n\t\t//标记事件发送错误\n\t\t//subscriber.onError();\n\t}\n});\n')])]),e._v(" "),n("hr"),e._v(" "),n("pre",[n("code",[e._v("//from(T[])，返回的对象一般都是数值类型\nInteger[] items = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nObservable observable = Observable.from(items);\n")])]),e._v(" "),n("hr"),e._v(" "),n("pre",[n("code",[e._v("//指定某一时刻进行数据发送\nObservable observable = Observable.interval(1, 1, TimeUnit.SECONDS);//每隔一秒发送数据\n")])]),e._v(" "),n("hr"),e._v(" "),n("pre",[n("code",[e._v("//just(T...)，处理任意类型的数组集合或数值，参数上限10个，参数类型必须一致\nInteger[] items1 = {1, 2, 3, 4, 5, 6};\nInteger[] items2 = {3, 5, 6, 8, 3, 8};\nObservable observable = Observable.just(items1, items2);\n")])]),e._v(" "),n("hr"),e._v(" "),n("pre",[n("code",[e._v("//使用范围数据，指定输出数据的范围（1-40的数值）\nObservable observable = Observable.range(1, 40);\n")])]),e._v(" "),n("p",[e._v("####创建事件的接收者（观察者|订阅者），onNext方法中的数据类型必须被观察者指定的泛型")]),e._v(" "),n("blockquote",[n("p",[e._v("onNext(T item)：Observable调用这个方法发射数据，方法的参数就是Observable发射的数据，这个方法可能会被调用多次，取决于业务逻辑")])]),e._v(" "),n("blockquote",[n("p",[e._v("onCompleted()：正常终止，在没有遇到错误的情况下，Observable在最后一次调用onNext之后调用此方法")])]),e._v(" "),n("blockquote",[n("p",[e._v("onError(Throwable e)：当Observable遇到错误或者无法返回期望的数据时会调用这个方法，这个调用会终止Observable，后续不会再调用onNext和onCompleted，onError方法的参数是抛出异常")])]),e._v(" "),n("pre",[n("code",[e._v('Observer<String> observer = new Observer<String>() {\n\n\t@Override\n\tpublic void onNext(String s) {\n\t\tSystem.out.println("onNext" + s);\n\t}\n\t\n\t@Override\n\tpublic void onCompleted() {\n\t\tSystem.out.println("onCompleted");\n\t}\n\t\n\t@Override\n\tpublic void onError(Throwable e) {\n\t\tSystem.out.println("onError" + e.getMessage());\n\t}\n};\n')])]),e._v(" "),n("hr"),e._v(" "),n("pre",[n("code",[e._v('//订阅者\nSubscriber<String> subscriber = new Subscriber<String>() {\n\n\t@Override\n\tpublic void onStart(String s) {\n\t\tSystem.out.println("事件开始了");\n\t}\n\n\t@Override\n\tpublic void onNext(String s) {\n\t\tSystem.out.println("onNext" + s);\n\t}\n\t\n\t@Override\n\tpublic void onCompleted() {\n\t\tSystem.out.println("onCompleted");\n\t}\n\t\n\t@Override\n\tpublic void onError(Throwable e) {\n\t\tSystem.out.println("onError" + e.getMessage());\n\t}\n};\n')])]),e._v(" "),n("hr"),e._v(" "),n("pre",[n("code",[e._v('//对订阅者进行简化，更简单\nAction1<String> action1 = new Action1<String>() {\n\n\t@Override\n\tpublic void call(String s) {\n\t\tSystem.out.println("call" + s);\n\t}\n};\n')])]),e._v(" "),n("h4",{attrs:{id:"订阅事件，被观察者必须指定了事件的接收者（观察者-订阅者），整个事件流程才可以被启动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#订阅事件，被观察者必须指定了事件的接收者（观察者-订阅者），整个事件流程才可以被启动","aria-hidden":"true"}},[e._v("#")]),e._v(" 订阅事件，被观察者必须指定了事件的接收者（观察者|订阅者），整个事件流程才可以被启动")]),e._v(" "),n("pre",[n("code",[e._v("observable.subscribe(observer);\n")])]),e._v(" "),n("hr"),e._v(" "),n("pre",[n("code",[e._v("observable.subscribe(subscriber);\n")])]),e._v(" "),n("hr"),e._v(" "),n("pre",[n("code",[e._v("//选择性参数方法，可对onNext，onCompleted，onError选择性使用，一般只需要onNext方法就足够\nobservable.subscribe(action1);\n\n//自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()\nobservable.subscribe(onNextAction);\n//自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()\nobservable.subscribe(onNextAction, onErrorAction);\n//自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()\nobservable.subscribe(onNextAction, onErrorAction, onCompletedAction);\n\n简单解释一下这段代码中出现的 Action1 和 Action0。 \nAction0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；\n由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。\n这样其实也可以看做将 onCompleted() 方法作为参数传进了 subscribe()，相当于其他某些语言中的『闭包』。\nAction1 也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；\n与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。\n事实上，虽然 Action0 和 Action1 在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法\n")])]),e._v(" "),n("blockquote",[n("p",[e._v("订阅者是观察者的子类，区别在于订阅者可以取消订阅（在程序销毁后）")])]),e._v(" "),n("pre",[n("code",[e._v("if(subscriber != null && !subscriber.isUnsubscribed()) {\n\tsubscriber.unsubscribe();\n}\n")])])])}),[],!1,null,null,null);r.default=o.exports}}]);
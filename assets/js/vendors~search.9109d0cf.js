(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{285:function(e,t,s){"use strict";s.r(t),t.default=[{title:"反编译asar文件去除electron-vue的waring信息",path:"/posts/remove-electron-vue-waring.html",strippedContent:" ##### 现象  1. 在使用``electron-vue``进行开发时，每次调试界面打开``devtools``调试，常看到烦人的``Warning ``信息。  ![waring.jpg](https://i.loli.net/2019/11/28/4HoEs2e8FQYxvkJ.png)    ##### ``security-warnings.js``  1. 审查元素发现该文件位于``node_modules\\electron\\dist\\resources\\electron.asar\\renderer\\security-warnings.js``,但是只能进到``node_modules\\electron\\dist\\resources``目录。那么如何去除``security-warnings.js``文件的警告信息呢。    ##### 反编译 ``security-warnings.js``  1. ``cnpm install -g asar`` // 全局安装asar  2. 备份一份``electron.asar``文件  3. 将要反编译``electron.asar`` 放在一个新建的文件夹里  4. 进入该文件夹执行命令``asar extract electron.asar ./`` 即可看到反编译后的文件目录![decompilation](https://i.loli.net/2019/11/28/jBIkQvdY1VEF2p4.png)  5. 打开``\\renderer\\security-warnings.js``,删除或注释对应警告行145,128,188,并保存  6. 开始打包``asar pack decompilation electron.asar`` // asar pack 目录 打包后的文件名  ![成功后的截图](https://i.loli.net/2019/11/28/K6iv2zkHEpRZVaG.png)  "},{title:"由浅入深学习webpack",path:"/posts/webpack.html",strippedContent:" ## 基础知识  ### 模块化  #### 模块化  ##### js模块化    1. js模块化          ###### 命名空间          1. 命名空间              1. 一个对象              语法:              ```js              库名.类别名.方法名              ```              ```js              var NameSpace = {}              NameSpace.type = NameSpace.type || {}              NameSpace.type.method = function(){}              ```          ######  common.js          2. common.js    (只能在服务器端使用)              1. 一个文件为一个模块              2. 只能通过``module.exports``暴露接口              3. 通过``require``引入模块              4. 同步执行          ######  Amd/Cmd/Um          3. Amd/Cmd/Umd  (规范化模块化开发)              - Amd                  1. 异步的模块定义                  2. 使用``define``定义模块                  3. 使用``require``加载模块                  4. 特点是依赖前置，提前执行              - Cmd                  1. 一个文件为一个模块                  2. 使用``define``定义模块                  3. 使用``require``加载模块                  4. 特点是尽可能懒执行              - Umd （通用解决方案）                  1. 首选判断是否支持``Amd``再判断是否支持``common.js``,如果都不支持，则将其定义为全局变量          ######  Es6 module          4. Es6 module   (es6模块化规范)              1. 一个文件为一个模块              2. 使用``import``引入模块              3. 使用``export``暴露接口  ##### css模块化                2. css模块化          1. OOCSS (设计结构分离)          2. SMACSS (减少代码量，代码维护)          3. Atomic CSS（原则化css）          4. MCSS (多层级css)          5. AMCSS (针对属性进行css设计)          6. BEM (BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier)  #### 核心概念  ##### Entry    1. Entry（打包入口）          1. 告诉webpack，这里的所有依赖模块，          2. 也是打包的入口          3. 可以是单个或多个              1. 可以是一个文件                   ```js                  module.exports = {                      entry : 'index.js'                  }                  ```              2. 可以是一个数组                   ```js                  module.exports = {                      entry : ['index.js','vendor.js']                  }                  ```              3. 可以是一个``key value``形式的对象                   ```js                  module.exports = {                      entry : {                          index : 'index.js'                      }                  }                  ```                                    1. 当entry是一个对象的时候，好处是                      1. 知道每一个entry对应的是什么                      2. 如果想要继续添加一个新的入口，可以继续指定key，可扩展性强                           ```config.js                          module.exports = {                              entry : {                                  index: 'index.js'，                                  home:  'home.js'，                                  vendor: ['vendor.js','app.js']                              }                          }                          ```    ##### Output    2. Output（打包输出）          1. 可以是一个或多个              1. 一个                             ```config.js                  module.exports = {                      entry : 'index.js'，                      output: {                          filename: 'index.min.js'                      }                  }                  ```              2. 多个                             ```config.js                  module.exports = {                      entry : {                          index: 'index.js'，                          home:  'home.js'，                      }                      output: {                          filename: '[name].min.[hash:5].js'                      }                  }                  ```                  name 表示的是entry的name，hash是在webpack打包的唯一的hash码                            2. 自定义规则    ##### Loaders    3. Loaders (处理其他类型的资源文件)          1. 处理文件          2. 转换为模块              1. code               ```js              module.exports = {                  module:{                      rules: [                          {                              test: /\\.css$/,                              use: 'css-loader'                          }                      ]                  }              }              ```              满足以.css结尾的使用，用css-loader转换              - 常用loader                  1. 编译相关                      -  ``babel-loader``,``ts-loader``                  2. 样式相关                      - ``style-loader``, ``css-loader``, ``less-loader``, ``postcss-loader``                  3.  文件相关                      - ``file-loader`` ， ``url-loader``    #####  Plugins    4. Plugins (压缩代码，混淆代码)          1. 可以参与到整个打包的过程          2. 打包优化和压缩          3. 配置编译时的变量              - code              ```js              const webpack = require('webpack')              module.export = {                  plugins:[                     new webpack.optimize.UglifyJsPlugin()                  ]              }              ```              - 常用Plugins                  1. 优化相关                     - ``CommonsChunkPlugin``, ``UglifyjsWebpackPlugin``                  2. 功能相关                     - ``ExtractTextWebpackPlugin`` ，``HtmlWebpackPlugin``, ``hotmodulereplacement``，``CopyWebpackPlugin``              - 相关名词                  1. Chunk （代码块）                  2. Bubdle （打包过的）                  3. Module （模块）  ### 开发环境  #### webpack 命令     1. ``webpack -h`` （可以看到命令行中所有的配置选项）     2. ``webpack -v``  (查看版本号)     3. ``webpack <entry> [<entry>] <output>`` (打包)  #### webpack 配置     1. 安装``webpack-cli`` ``cnpm i webpack-cli -g``         1. 可以交互式初始化一个项目 ``webpack-cli``        2. 可以进行项目迁移     2. 打包js        1. 如果想想直接使用webpack，则名称为webpack.config.js，否则执行命令为 webpack --config webpack.xxx.js              ```config.js                 //js文件没有发生变化，打包后的哈希值不会变化                 module.exports = {                     entry: {                         app: './app.js'                     },                     output: {                         filename: '[name].[hash:5].js'                     }                 }              ```  ### 框架配合  #### Vue-cli  1. Vue-cli  #### Angular-cli  2. Angular-cli  #### React-starter  3. React-starter    ### 文件处理  #### 编译Es 6/7  ##### Babel     1. Babel          ###### Babel-loader          1. Babel-loader              1. webpack中使用Babel                   1.                   ```bash                  cnpm install babel-loader@8.0.0-beta.0 @babel/core                  ```                  2. ``npm init`` 一直回车生成``package.json``文件                  3. 新建文件``app.js``,``index.html``,``webpack.config.js``                     1. app.js                     2. index.html                     3. webpack.config.js                     ```js                      module.exports = {                          entry: {                              app: './app.js'                          },                          output: {                              filename: '[name].[hash:5].js'                          },                          module:{                              rules:[                                  {                                      test: /\\.js$/,                                      use:{                                          loader: 'baber-loader',                                          options:{                                              presets:['@babel/preset-env']                                          }                                      },                                      exclude:'/node_module/'                                  }                              ]                          }                      }                     ```                     执行 ``cnpm install  bebel-loader --save-dev``, ``cnpm install  babel-core --save-dev``, ``cnpm install @babel/preset-env --save-dev``                  4. Babel Parests中的targets参数(根据指定的参数，选择是否编译):                      1. targets.browsers（指定浏览器）数据来源于browsweslist                          1. target.browsers:\"last 2 versions\" (最后两个版本执行)                          2. target.browsers:\">1%\"（大于全球占有率1%的执行）                          3. 配置                          ```js                          module.exports = {                              entry: {                                  app: './app.js'                              },                              output: {                                  filename: '[name].[hash:5].js'                              },                              module:{                                  rules:[                                      {                                          test: /\\.js$/,                                          use:{                                              loader: 'baber-loader',                                              options:{                                                  presets:[                                                      ['@babel/preset-env',{                                                          targets : {                                                              browsers : ['> 1%','last 2 versions']                                                          }                                                      }]                                                  ]                                              }                                          },                                          exclude:'/node_module/'                                      }                                  ]                              }                          }                          ```           ###### Babel-Polyfill             2. Babel-Polyfill(浏览器标注)              1. 可以全局使用              2. 为开发应用准备的              3. 使用                   1.                   ```bash                  yarn add babel-polyfill --save                  ```                  2.                   ```bash                  import 'babel-polyfill'                  ```          ###### Babel Runtime Transform             3. Babel Runtime Transform                  1. 局部使用              2. 为开发框架准备的              3. 使用                   1.                    ```bash                  yarn add babel-plugin-transform-runtime --save-dev                 ```                  2.                    ```bash                  yarn add babel-runtime --save                 ```                  3. 项目文件夹下新建``·babelrc``文件,在该文件里进行配置          ###### .babelrc          4. ``.babelrc``文件的配置              ```config.js              {              presets:[                  ['@babel/preset-env',{                      targets : {                          browsers : ['> 1%','last 2 versions']                      }                  }]              ],              plugins: [\"@babel/plugin-transform-runtime\"]              }              ```     ##### Typescript     2. Typescript        ###### 使用Typescript        1. 使用Typescript           1. 安装Typescript              ```bash              yarn add ts-loader --save-dev              ```           2. webpack.config.js配置               ```js                 module.exports = {                     entry: {                         app: './app.ts'                     },                     output: {                         filename: '[name].[hash:5].js'                     },                     module:{                         rules:[                             {                                 test: /\\.tsx?$/,                                 use:{                                     loader: 'ts-loader',                                     options:{                                         presets:[                                             ['@babel/preset-env',{                                                 targets : {                                                     browsers : ['> 1%','last 2 versions']                                                 }                                             }]                                         ]                                     }                                 },                                 exclude:'/node_module/'                             }                         ]                     }                 }               ```           3. tsconfig.json              ```json              {                \"compilerOptions\": {                  \"module\": \"commonjs\",                  \"target\": \"es5\",                  \"allowJs\": true,                  \"sourceMap\": true                },                \"exclude\": [                  \"node_modules\"                ]              }              ```           4. 使用lodash               1. 安装``yarn lodash --save``                 2. 使用                   ```ts                  import * as _ from 'lodash'                  const arr = [1,5,6];                  console.log(_.chunk(arr));                 ```           5. 全局使用typings              1. 安装                  ```bash                  yarn add typings -g                 ```               2. 使用                  ```bash                  typings install loadsh                 ```                   3. 安装成功后，文件夹下会新生成 ``typings.json`` 的配置文件和``typings`` 文件夹              4. 需在``tsconfig.json``中添加配置,typeRoots是告诉ts打包编译的时候，要到什么地方去找申明文件，这时代码编译报错便有提示                 ```                 \"typeRoots\": [                   \"./node_modules/@type\",                   \"./typings/modules\"                 ]                 ```     ### 打包优化     #### 提取公共代码     1. 提取公共代码        ##### 好处        1. 好处           1. 减少代码冗余           2. 提高加载速度        ##### 使用插件CommonsChunkPlugin        2. 使用插件CommonsChunkPlugin            ##### 配置           1. 只需要在配置中添加               ```                  {                      plugins: [                          new webpack.optimize.CommonsChunkPlugin(options)                      ]                  }               ```            ##### options的配置项           2. options的配置项              1. ``name/names`` 给那些文件提出来公用               2. ``filename``  打包后的文件名              3. ``minChunks`` 接受的值是数字表示你这个公共代码出现的次数，也可以是函数，以及自定义逻辑              4. ``chunks`` 指定代码提取范围              5. ``children`` 在模块/所有模块查找公共模块               6. ``deepChildren`` 在模块/所有模块查找公共模块              7. ``async`` 异步公共代码块           ##### 应用场景           3. 应用场景              1. 单页应用              2. 单页应用+第三方依赖              3. 多页引用 + 第三方依赖 + webpack生成代码           ##### 配置           4. 配置              ```js              const webapck = require('webpack');              const path = require('path');                            module.exports = {                  entry: {                      'pageA': './pageA',                      'pageB': './pageB',                      'vendor': ['lodash']                  },                  output: {                      path: path.resolve(__dirname, './dist'),                      filename: \"[name].bundle.js\",                      chunkFilename: \"[name].chunk.js\"                  },                                plugins: [                      new webapck.optimize.CommonsChunkPlugin({                          name: 'common',                          minChunks: 2                      })                  ]              };              ```                1. ``__dirname`` 当前文件路径                2. 这样打包的缺点：没有区分第三方模块代码和业务代码                3. 将配置优化为                    ```js                      const webapck = require('webpack');                      const path = require('path');                                            module.exports = {                          entry: {                              'pageA': '.pageA',                              'pageB': '.pageB',                              'vendor': ['lodash'] //可以是一个数组。第三方包                          },                          output: {                              path: path.resolve(__dirname, './dist'),                              filename: \"[name].bundle.js\",                              chunkFilename: \"[name].chunk.js\"                          },                                                plugins: [                              new webapck.optimize.CommonsChunkPlugin({                                  name: 'vendor',                                  minChunks: Infinity                              }),                                                    new webapck.optimize.CommonsChunkPlugin({                                  name: 'mainfest',                                  minChunks: Infinity                              })                          ]                      };                   ```                      1. 以上代码还可以再优化                          ```js                          const webapck = require('webpack');                          const path = require('path');                                                    module.exports = {                              entry: {                                  'pageA': '.pageA',                                  'pageB': '.pageB',                                  'vendor': ['lodash']                              },                              output: {                                  path: path.resolve(__dirname, './dist'),                                  filename: \"[name].bundle.js\",                                  chunkFilename: \"[name].chunk.js\"                              },                                                        plugins: [                                  new webapck.optimize.CommonsChunkPlugin({                                      name: 'common',                                      minChunks: 2,                                      chunks: ['pageA', 'pageB']  //指定需要提取公共文件的范围提取                                  }),                                                            new webapck.optimize.CommonsChunkPlugin({                                      names: ['vendor', 'mainfest'],                                      minChunks: Infinity                                  }),                              ]                          };                                                    ```     #### 代码分割和懒加载     2. 代码分割和懒加载             1. 在通过改变写代码的方式上实现代码分割和懒加载              ##### webapck  methods              1. webapck  methods wenpack内置方法                  1. require.ensure 该方法接受四个参数，该方法动态的加载一个模块                     1. []: dependencies   依赖。加载进来，并不会执行，在callback中require下才会执行                          2. callback                             3. errorCallback 可省略                     4. chunkName                      2. require.include 后面直接一个参数。                     1. 引入进来不执行。                     2. 作用是：两个模块依赖了第三方模块。可以把第三方模块放在父模块里，在打包时，不在子模块加载，只加载与父模块              ##### ES2015 Loader spec                       2.  ES2015 Loader spec                      1. 场景                      1. 分离业务代码 第三方代码                      2. 分离业务代码 业务公共代码 第三方依赖                      3. 分离首次加载 访问后加载的代码                  2. 实例                      1. webpack.config.js                          ```js                          const webapck = require('webpack');                          const path = require('path');                                                    module.exports = {                              entry: {                                  'pageA': './pageA'                              },                              output: {                                  path: path.resolve(__dirname, './dist'),                                  filename: \"[name].bundle.js\",                                  chunkFilename: \"[name].chunk.js\"                              }                          };                          ```                      2. paegA.js                          ```js                          import './subPageA'                          import './subPageB'                                                    require.ensure(['lodash'], function () {                              const _ = require('lodash');                              _.join([1, 2], 3);                          }, 'vendor');                                                    export default 'pageA'                         ```                       3. pageA中提取公共的模块subPageA和subPageB                          1.pageA.js                          ```js                          if(page === 'subPageA') {                              require.ensure(['./subPageA'], function() {                                  const subPageA = require('./subPageA');                              }, 'subPageA');                          } else if(page === 'subPageB') {                              require.ensure(['./subPageB'], function() {                                  const subPageB = require('./subPageB');                              }, 'subPageB');                          }                                                    require.ensure(['lodash'], function () {                              const _ = require('lodash');                              _.join([1, 2], 3);                          }, 'vendor');                                                    export default 'pageA'                          ```                      4. 动态import分割代码                          ```javascript                          require.include('./moduleA');                                                    const page = 'subPageA';                                                    if(page === 'subPageA') {                              import(                                  /* webpackChunkName:'subPageA' */                                  './subPageA').then(function(subPageA) {                                  console.log(subPageA);                              })                          } else if(page === 'subPageB') {                              import(                                  /* webpackChunkName:'subPageA' */                                  './subPageB').then(function(subPageB) {                                  console.log(subPageB);                              })                          }                                                    require.ensure(['lodash'], function () {                              const _ = require('lodash');                              _.join([1, 2], 3);                          }, 'vendor');                                                    export default 'pageA'                          ```                         5. async分隔代码                          ```javascript                          const webapck = require('webpack');                          const path = require('path');                                                    module.exports = {                              entry: {                                  'pageA': './pageA',                                  'pageB': './pageB',                                  'vendor': ['lodash']                              },                              output: {                                  path: path.resolve(__dirname, './dist'),                                  filename: \"[name].bundle.js\",                                  publicPath: \"./dist/\",                                  chunkFilename: \"[name].chunk.js\"                              },                                                        plugins: [                                  new webapck.optimize.CommonsChunkPlugin({                                      async: 'async-common',                                      children: true,                                      minChunks: 2                                  }),                                  new webapck.optimize.CommonsChunkPlugin({                                      names: ['vendor', 'mainfest'],                                      minChunks: Infinity                                  })                              ]                          };                          ```     #### 处理css      3. 处理css         1. ##### style-loader           1. style-loader 创建标签               1. 安装                ```bash               yarn add css-loader style-loader --dev               ```               2. app.js               ```javascript               import \"./style.css\"               ```               3. 配置               ```javascript                  const path = require('path');                                    module.exports = {                      entry: {                          app: './app.js'                      },                                        output: {                          path: path.resolve(__dirname, 'dist'),                          filename: '[name].bundle.js',                          publicPath: './dist/'                      },                                        module: {                          rules: [                              {                                  test: /\\.css$/,                                  use: [                                      {                                          loader: 'style-loader'                                      },                                      {                                          loader: 'css-loader'                                      }                                  ]                              }                          ]                      }                  };               ```               style-loader 需要写在css-loader前面           2. ##### style-loader/url              1. 使用style-loader的webpack.config.js的地方 直接使用style-loader/url，样式文件可以直接link进来。但是这种使用还需要一个file-loader. 之前使用css-loader的地方，要改为使用file-loader                 这种情况下的打包，会直接打包出来一个单独的css文件。不常用。因为不能处理多个样式。若处理多个样式，则需要多个link标签           3. ##### style-loader/useable              1. 可以在style-loader中控制是否插入到页面中去              ```javascript              module: {                      rules: [                          {                              test: /\\.css$/,                              use: [                                  {                                      loader: 'style-loader/useable'                                  },                                  {                                      loader: 'css-loader'                                  }                              ]                          }                      ]                  }              ```              pachage.json配置后。引入的样式文件会获得两个方法``use()``控制样式显示和``unuse()``控制样式不显示              ```javascript              import base from './css.css'                            var flag = false;                            setInterval(function(){                  if(flag) {                      base.unuse();                  } else {                      base.use();                  }                  flag = !flag              }, 500);              ```             4. style-loader的配置                1. options                    1. insertAt (插入位置)                    2. insertInto (插入到具体的dom)                    3. singleton (是否使用一个style标签)                    4. transform (转化，在浏览器环境下，插入页面前)                    5. package.json                          ```javascript                          module.export = {                              module: {                                      rules: [                                          {                                              test: /\\.css$/,                                              use: [                                                  {                                                      loader: 'style-loader',                                                      options: {                                                          insertInto: '#app',                                                          singleton: true,                                                          transform: './css.transform.js' //css变形的路径。相对于config.js的路径                                                      }                                                  },                                                  {                                                      loader: \"css-loader\"                                                  }                                              ]                                          }                                      ]                                  }                          }                          ```                     6. css.transform.js                        ```css.transform.js                          module.exports =function(css) {                              console.log(loading);                              console.log(css);                              console.log(window.innerHeight);                              return css;                          };                        ```                        ``css.transform.js``文件可以拿到所有的css样式        2. ##### css-loader           2. css-loader  在JS中直接require加载css样式文件              1. options:                 1. alias(解析别名,路径映射)                 2. importLoader(支持@import,取决于css-loader后面是否有其他的loader才有用)                 3. Minimize(是否压缩样式文件，职位true和false)                 4. modules(是否启用css-modules)                 2. css-modules                  1. :local(本地样式)                  2. :global(定义全局样式)                  3. compose(继承样式)                  4. compose ... from (从某一个文件里引入样式)           ##### less/sass        3. less/sass              1. 安装                 ```bash                 yarn add less-loader less --save-dev                 yarn add sass-loader node-sass --save-dev                 ```           2. 配置              ```javascript              module: {                  rules: [                      {                          test: /\\.less$/,                          use: [                              {                                  loader: 'style-loader',                                  options: {                                      singleton: true,                                      transform: './css.transform.js'                                  }                              },                              {                                  loader: 'css-loader',                                  options: {                                      minimize: true,                                      modules: true,                                      localIdentName: '[path][name]_[local]_[hash:base64:5]'                                  },                              },                              {                                  loader: 'less-loader'                              }                          ]                      }                  ]              }              ```            ##### 提取css             4.  提取css            1. extract-loader             2. ExtractTextWebpackPlugin               1. 安装               ```bash               yarn add extract-text-webpack-plugin --save-dev               ```               2. 使用                   1. webpack.config.js                   ```webpack.config.js                   let path = require('path');                   let ExtractTextWebpackPlugin = require('extract-text-webpack-plugin');                                         module.exports = {                       entry: {                             app: './app.js'                         },                                               output: {                             path: path.resolve(__dirname, 'dist'),                             filename: '[name].bundle.js',                             publicPath: './dist/',                             chunkFilename: '[name].bundle.js',                         },                                               module: {                             rules: [                                 {                                     test: /\\.less$/,                                     use: ExtractTextWebpackPlugin.extract({                                         fallback: {                                             loader: 'style-loader',                                             options: {                                                 singleton: true,                                                 transform: './css.transform.js'                                             }                                         },                                        use: [                                             {                                                 loader: 'css-loader',                                                 options: {                                                     minimize: true,                                                     modules: true,                                                     localIdentName: '[path][name]_[local]_[hash:base64:5]'                                                 },                                             },                                             {                                                 loader: 'less-loader'                                             }                                         ]                                     })                                 }                             ]                         },                                             plugins: [                           new ExtractTextWebpackPlugin({                               filename: '[name].min.css',                               allChunks: false                           })                       ]                   };                   ```                   2. app.js                   ```javascript                   import base from './css/base.less'                   import common from './css/common.less'                                     let app = document.getElementById('app');                   app.innerHTML = `<div class=\"${base.box}\"></div>`;                                     //实现异步加载a模块                   import(                       /* webpackChunkName: 'a' */                       './components/a'                       ).then(function(a) {                           console.log(a)                   });                  ```     #### 文件处理     ##### 图片处理     1. 图片处理        1. css中引入的图片           1. file-loader               1. 安装                  ```bash                  yarn add file-loader --save                  ```               2. 配置                  ```package.json                  module.exports = {                      entry: {                          app: './app.ts'                      },                      output: {                          filename: '[name].[hash:5].js'                      },                      module:{                          rules:[                              {                                  test: /\\.(png|jpg|jpeg|gif)?$/,                                  use:{                                      loader: 'file-loader',                                      options: {                                         publicPath:''//根目录                                         outputPath:'filename/', //指定目录下                                         useRelativePath: true //每个文件生成一个相对url的context                                    }                                  },                              }                          ]                      }                  }                  ```        2. 自动合并成雪碧图           1. postcss-sprites               1. 安装                   ```bash                   yarn add postcss-sprites --save                   ```               2. 配置                  ```package.json                  module.exports = {                      entry: {                          app: './app.ts'                      },                      output: {                          filename: '[name].[hash:5].js'                      },                      module:{                          rules:[                              {                                  test: /\\.(png|jpg|jpeg|gif)?$/,                                  use:{                                      loader: 'post-loader'                                      options: {                                              ident: 'postcss',                                              plugins: [                                                  //打包生成雪碧图的配置                                                  require('postcss-sprites')({                                                      //雪碧图打包后的地址                                      \t\t\t\tspritePath: 'dist/assets/imgs/',                                                      //适应高分辨率视口 // 2倍图等                                                      retina: true                                                  }),                                                  require('postcss-cssnext')()                                              ]                                          }                                  },                              }                              //修改雪碧图的名字                              {                                          loader: 'url-loader',                                  options: {                                      name: '[name]-[hash:5]-min.[ext]', //ext 是文件后缀                                      limit: 200,                                      //publicPath: '',                                      //outputPath: '',                                      //将打包生成的文件关联原文件夹                                      useRelativePath: true                                  }                              },                          ]                      }                  }                  ```        3. 压缩图片           1. img-loader               1. 安装                   ```bash                   yarn add img-loader --save                   ```               2. 配置                  ```package.json                  module.exports = {                      entry: {                          app: './app.ts'                      },                      output: {                          filename: '[name].[hash:5].js'                      },                      module:{                          rules:[                              {                                  test: /\\.(png|jpg|jpeg|gif)?$/,                                  use:{                                      loader: 'img-loader',                                      options: {                                          quality:100                                      }                                  },                              }                          ]                      }                  }                  ```        4. base64编码           1. url-loader               1. 安装                   ```bash                   yarn add url-loader --save                   ```               2. 配置                  ```package.json                  module.exports = {                      entry: {                          app: './app.ts'                      },                      output: {                          filename: '[name].[hash:5].js'                      },                      module:{                          rules:[                              {                                  test: /\\.(png|jpg|jpeg|gif)?$/,                                  use:{                                      loader: 'url-loader',                                      options: {                                      //当图片大小小于限制时会自动转成 base64 码,不生成图片                                          limit: 800                                      }                                  },                              }                          ]                      }                  }                  ```     ##### 字体文件     1. 字体文件        1. 配置            ```package.json            module.exports = {                entry: {                    app: './app.ts'                },                output: {                    filename: '[name].[hash:5].js'                },                module:{                    rules:[                        {                            {                                test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,                                loader: 'url-loader',                                options: {                                    name：'[name]-[hash:5].[ext]'                                    limit: 1000,                                    publicPath:''                                    outputPath:'filename/',                                    useRelativePath: true                                  }                            }                        }                    ]                }            }            ```     ##### 第三方js库     1. 第三方js库        1. script标签引入可以直接使用        2. ProvidePlugin            1. 安装               ```bash               yarn add jquery --save               ```           2. 配置               ```javascript               new webpack.ProvidePlugin({                  $: 'jquery',                  jQuery: 'jquery'                })               ```           3. imports-loader           1. 安装              ```bash              yarn add imports-loader --save              ```           2. 配置               ```webpack.config.js               module.exports = {                   module: {                       rules: [                           {                               test: path.resove(_dirbane,'src/app.js'),                               use: [                                  {                                      loader:'imports-loader',                                      options:{                                           $: 'jquery',                                      }                                  }                                  ]                           }                       ]                   }               };               ```       ##### HTML in webpack     1. HTML in webpack        1. html-webpack-plugin           1. 安装              ```bash              yarn add html-webpack-plugin --save-dev              ```           2. options 配置项              1. template(模板文件,可以是html,ejs等结尾,默认为index.html)              2. filename(文件名,默认为index.html)              3. minify(是否压缩)              4. chunks(指定有哪几个excludeChunks加入到页面中去,默认会选所有)              5. inject(是否让html-webpack-plugin将想要的css样式插入到页面中,默认为true)              6. excludeChunks(排除的chunks)           3. 配置              1. webpack.config.js                  ```javascript                  var HtmlWebpackPlugin = require('html-webpack-plugin');                  var path = require('path');                                    module.exports = {                    entry: 'index.js',                    output: {                      title: '首页', // (生成html文件的标题)                      favicon: './favicon.ico',// (icon的url)                      path: path.resolve(__dirname, './dist'),                      template: './src/index.html', // (模板文件,可以是 html,jade,ejs,hbs等等,如果你设置的 title 和 filename于模板中发生了冲突，那么以你的title 和 filename 的配置值为准。)                      filename: 'index_bundle.html', // (打包后生成html文件的名字)                      inject:false,  /*  注入选项。有四个选项值 true, body, head, false                                      *  true:默认值，script标签位于html文件的 body 底部                                      *  body:script标签位于html文件的 body 底部（同 true）                                      *  head:script标签位于head标签内                                      *  false:不插入生成的js文件，只是单纯的生成一个 html文件                                     */                      minify:{                            collapseWhitespace: true, // (清理html中的空格、换行符。默认值false)                             removeComments: true, // (清理html中的注释,默认值false)                            removeRedundantAttributes: true, // (删除多余的属性,默认值false)                             removeScriptTypeAttributes: true, // (删除script的类型属性，在h5下面script的type默认值：text/javascript 默认值false)                             removeStyleLinkTypeAttributes: true, // (删除style的类型属性,默认值false)                             useShortDoctype: true, // (使用短的文档类型，将文档转化成html5，默认false)                            minifyCSS: true, // (压缩html内的css。默认值false)                            minifyJS: true, // (压缩html内的js。默认值false)                            caseSensitive: true, // (是否对大小写敏感，true为大小写敏感，false则大小写不敏感，会全部转为小写)                         },                      hash: true, // (默认false。当设置为true时，给注入的js生成一个hash值（XXX.js?22b9692e22e7be37b57e），以防止缓存)                      cache: true, // (默认true。内容变化的时候生成一个新的文件)                      showErrors: true, // (默认true。如果webpack编译出现错误，webpack会将错误信息包裹在一个 pre 标签内，也就是显示错误信息,方便定位错误)                      chunks: ['index'], // (编译后的html引入的js入口文件)                      excludeChunks: ['home'] // (同chuncks相反，是编译后的html排除的js入口文件)                     },                    plugins: [new HtmlWebpackPlugin()]                  };                  ```     ##### HTML-loader     1. HTML-loader        1. 安装           ```bash           yarn add  -D html-loader           ```         2. 配置           1. options           2. webpack.config.js               ```javascript                {                 test: /\\.(html)$/,                 use: {                   loader: 'html-loader',                   options: {                     attrs: [':data-src'] // attrs 默认值:data-src                   }                 }               }               ```      #### 配合优化     1. 配合优化        1. 提前载入webpack加载代码           1. inline-manifest-webpack-plugin (将webpack生成的代码插入到html中,和html-loader配合时会有bug)           2. html-webpack-inline-chunk-plugin (将选择的chunk插入到html中)              1. 安装html-webpack-inline-chunk-plugin                  ```bash                 yarn add html-webpack-inline-chunk-plugin --save-dev                 ```              2. 安装babel                 ```bash                 yarn add babel-core babel-loader baber-preset-env --save                 ```              3. 配置                  ```webpack.config.js                 const HtmlWebpackInlineChunkPlugin=require('html-webpack-inline-chunk-plugin')                                   module.exports = {                      plugins:[                             new HtmlWebpackInlineChunkPlugin({                                    inlineChunks:['manifest']                             })                             new webpack.optimize.CommonsChunkPlugin({                                    //自己生产的公共代码取名为manifest                                    name:'manifest'                             })                         ]                    //使用的时候要注意不要和Htmlwebpackplugin的chunk起冲突                  }                  ```    ### 开发环境  #### webpack Watch Mode  #####  clean-webpack-plugin  1. clean-webpack-plugin      1. 安装clean-webpack-plugin          ```bash         yarn add clean-webpack-plugin -D         ```     2. 配置        ```webpack.config.js        const CleanWebpackPlugin = require('clean-webpack-plugin');          module.exports = {          plugins: [           new CleanWebpackPlugin(),          ],          output: {            filename: '[name].bundle.js',            path: path.resolve(__dirname, 'dist')          }        };        ```     3. 执行 ``webpack -watch --progress --display-reasons --color``  #####  webpack-dev-server  2. webpack-dev-server     1. 功能        1. live reloading (刷新浏览器)        2. 路径重定向        3. 浏览器中显示编译错误        4. https          5. 接口代理        6. 热更新(不在刷新浏览器的情况下，进行热更新)     2. 安装         ```bash         yarn add webpack-dev-server --save-dev         ```     3. devServer         1. inline (页面打包状态，默认为true)         2. contentBase (提供内容的路径, 如果内容是静态的需要配置,默认是当前目录)         3. port (监听端口)         4. historyApiFallback (在使用html5的history api 的时候,如果访问某一个路径不会导致404,去指定一个重定向规则)         5. https (指定为true后，就会本地生产证书)         6. proxy (远程接口的代理)         7. hot (打开模块热更新，在某一个时间代码替换)         8. openpage (最先打开的页面，初始页面位置)         9. lazy (不编译所有的页面, 只会在打开某个页面的时候才会去编译 ,设置为懒模式 在多页面开发非常有用)         10. overlay (当页面出现错误的时候, 出现一个页面遮罩错误提示)      4. 配置         1. package.json             ```json              \"scripts\": {                \"server\":\"webpacki-dev-server --open\"             }             ```         2. webpack.config.js             ```webpack.config.js               module.exports={                 entry:{},                 output:{},                 plugins:[],                 modules:{},                 devServer:{                    port:9001,                    historyApiFallback:{                       rewrites:[                          {                             from:/^\\([a-zA-Z0-9]+\\/?)([a-zA-Z0-9]+)/, //规则                             to:function(context){                                retrun '/'+context.match[1]+  context.match[2]+'.html'                             }                          }                       ]                    }                 }              }             ```  #####  Proxy  3. Proxy      1. http-proxy-middleware         1. options            1. target (指定代理的地址)            2. changeOrigin (是否允许跨域，默认为false)            3. headers (增加请求https请求头)            4. logLevel (帮助调试的, 在控制台命令行中显示代理情况，代理信息)            5. pathRewrite (重定向接口请求)         2. 配置              1. ajax                 ```javascript                   $.get('/comments/show',{                      id:'4193566666',                      page:1                  },function(data){                      console.log(data)                  })                 ```             2. webpack.config.js                 ```webpack.config.js                   module.exports={                     entry:{},                     output:{},                     plugins:[],                     modules:{},                     devServer:{                        port:9001,                        historyApiFallback:{                           rewrites:[                              {                                 from:/^\\([a-zA-Z0-9]+\\/?)([a-zA-Z0-9]+)/, //规则                                 to:function(context){                                    retrun '/'+context.match[1]+  context.match[2]+'.html'                                 }                              }                           ]                        },                        proxy:{                           '/':{                              target:'https://m.weibo.cn',                              changeOrigin:true, // 允许跨域                              logLevel :'debug', // 控制台输出从发送请求到响应的详细信息                              pathRewrite :{                                  '^/comments':'/api/comments'                               },                               headers:{                                  'Cookie':'真实的cookie，可以从浏览器控制台获取'                               }                           }                        }                     }                  }                 ```        #####  模块热更新  1. Hot Module Replacement ([模块热更新](https://flynacl.gitbooks.io/webpack/content/api/hot-module-replacement.html))     1. 好处        1. 保持应用数据状态        2. 节省调试时间        3. 调试样式更快     2. 配置         1. webpack.config.js             ```webpacj.config.js                 module.exports={                   entry:{},                   output:{},                   plugins:[                      new webpack.HotModuleReplacementPlugin(),                      new webpack.NameMoudlesPlugin()                   ],                   modules:{},                   devServer:{                      port:9001,                      historyApiFallback:{                         rewrites:[                            {                               from:/^\\([a-zA-Z0-9]+\\/?)([a-zA-Z0-9]+)/,                               to:function(context){                                  retrun '/'+context.match[1]+  context.match[2]+'.html'                               }                            }                         ]                      },                      proxy:{                         '/':{                            target:'https://m.weibo.cn',                            changeOrigin:true,                            logLevel :'debug',                             pathRewrite :{                                '^/comments':'/api/comments'                             },                             headers:{                                'Cookie':'....'                             }                         }                      },                      hot:true,  //热更新启用                      hotOnly:true //不刷新浏览器                   }                }              ```   ##### 调试  1. source map 调试     1. 开启 source map        1. 通过配置的参数Devtool开启           1. Development(有七个值，开发环境下使用的有五个)               1. eval               2. eval-source-map               3. cheap-eval-source-map               4. cheap-modlue-eval-source-map               5. cheap-module-source-map           2. prduction(生产环境下，值有三个)                 1. source-map               2. hidden-source-map               3. nosource-source-map          2. 通过webpack.SourceMapDevToolPlugin        3. 通过webapck.EvakSourceMapDevToolPlugin     2. 配置         1. webpack.config.js              ```webpacj.config.js                 module.exports={                   entry:{},                   output:{},                   plugins:[                      new webpack.HotModuleReplacementPlugin(),                      new webpack.NameMoudlesPlugin()                   ],                   modules:{},                   devServer:{                      port:9001,                      historyApiFallback:{                         rewrites:[                            {                               from:/^\\([a-zA-Z0-9]+\\/?)([a-zA-Z0-9]+)/,                               to:function(context){                                  retrun '/'+context.match[1]+  context.match[2]+'.html'                               }                            }                         ]                      },                      proxy:{                         '/':{                            target:'https://m.weibo.cn',                            changeOrigin:true,                            logLevel :'debug',                             pathRewrite :{                                '^/comments':'/api/comments'                             },                             headers:{                                'Cookie':'....'                             }                         }                      },                      hot:true,  //热更新启用                      hotOnly:true //不刷新浏览器                      devtool:'cheap-module-source-map'                   }                }              ```      3. cssloader 加sourcemap : true 必须到options 里面的     4. singleton: true, // 使用一个style标签  singleton必须为false  ##### 通过Eslint检查代码格式  1. Eslint     1. 安装         ```bash          yarn add eslint eslint-loader eslint-plugin-htm eslint-friendly-formatter -D         ```         1. eslint-loader (解析器)            1. options.failOnWarning (默认为false,当设置为false，代码出现错误，不会通过编译)            2. options.failOnError (默认为false,当设置为false，代码出现错误，不会通过编译)            3. options.formatter (设置第三方友好提示的formatter)            4. options.outputReport (输出代码报告)         2. eslint-plugin-html (检查html里的js)         3. eslint-friendly-formatter (报错时输出格式)     2. 配置eslint        1. 根目录下新建``.eslintrc.js``文件           ```.eslintrc.js            module.exports={               root:true,               extends:'standard',  // 使用标准               plugins:[                   //安装之前的html 插件                   'html'               ],               //定义环境                env:{                   // 浏览器                   brower:true,                   // node                   node:true               },               //定义规则               rulse:{                     indent: ['error',4] // 缩进为4 前面的是这条规则的重要性。可以是warning/error                     'eol-last':['error','error'] // 不需要换行                  },               //把不允许的全局变量设为允许               globals:{                   $:true               }           }           ```        2. webpack.config.js            ```javascript             rules:[                {                    test:/\\.js$/,                    //eslint检测的文件                    include:[path.resolve(__dirname, 'src')],                    //eslint不检测文件                    exclude:[path.resolve__dirname,'src/libs')]                    use:[                        {                            loader:'babel-loader',                            options:{                                presets:[''env']                            }                        },                        {                            loader:'eslint-loader',                            options:{                                formatter:require('eslint-friendly-formatter')                            }                        }                    ]                }            ]            ```  ##### 开发环境和生产环境  1. 生产环境     1. 提取公共代码     2. 压缩混淆     3. 文件压缩     4. 去除无用代码  2. 开发环境  3. 开发环境和生产环境的共同点     1. 同样的入口     2. 同样的代码loader处理     3. 同样的解析配置  4. wenpack-merge      1. wenpack.dev.conf.js // 开发环境      2. webpack.prod.conf.js // 生产环境      3. webpack.common.conf.js //开发生产环节都会 用到  5. build配置项     1. webpack.common.conf.js        ```webpack.common.conf.js        const productionConfig = require('./webpack.prod.conf');        const developmentConfig = require('./webpack.dev.conf');                const merge = require('webpack-merge');        const ExtractTextWebpackPlugin = require('extract-text-webpack-plugin');                const path = require('path');        const Webpack = require('webpack');        const HtmlWebpackPlugin = require('html-webpack-plugin');                const generateConfig = env => {            /*插件部分*/            //提取代码的公用插件            const extractLess = new ExtractTextWebpackPlugin({                filename: (getPath) => {                    return getPath('css/[name].min.[hash:5].css').replace('css/js', 'css');                },                allChunks: false            });                            /*loader部分*/            // 打包编译JS            const scriptLoader = [                {                    loader: 'babel-loader'                }            ];            //打包编译css            const cssLoaders = [                {                    loader: 'css-loader',                    options: {                        minimize: env === 'production',                        // modules: true,                        localIdentName: '[path][name]_[local]_[hash:base64:5]'                    },                },                {                    loader: 'postcss-loader',                    options: {                        ident: 'postcss',                        sourceMap: env === 'development',                        plugins: [                            require('postcss-cssnext')()                        ].concat(                            env === 'production' ?                                require('postcss-sprites')({                                    spritePath: './dist/assets/img/sprites',                                    retina: true                                }) : []                        )                    }                },                {                    loader: 'less-loader'                }            ];            //打包编译样式            const styleLoader = env === 'production'                ? ExtractTextWebpackPlugin.extract({                    fallback: {                        loader: 'style-loader',                        options: {                            singleton: true,                            transform: './css.transform.js'                        }                    },                    use: cssLoaders                }) : [{                    loader: 'style-loader',                    options: {                        // singleton: true,                        transform: './css.transform.js',                        sourceMap: true                    }                }].concat(cssLoaders);            // 打包编译文件            const fileLoader = env === 'development' ? [                {                    loader: 'file-loader',                    options: {                        options: {                            outputPath: './img/',                        }                    }                }            ] : [                {                    loader: 'url-loader',                    options: {                        limit: 1024 * 2,                        fallback: {                            loader: 'file-loader',                            options: {                                outputPath: './img/',                            }                        }                    }                }            ];                    return {                entry: {                    app: './src/app.js'                },                        output: {                    path: path.resolve(__dirname, '../dist'),                    filename: 'js/[name].bundle.[hash:5].js',                    publicPath: '/',                    chunkFilename: '[name].bundle.[hash:5].js',              //动态打包文件名                },                        resolve: {                    alias: {                        jquery$: path.resolve(__dirname, '../src/lib/jquery.min.js')                  // 之所以要用jquery$ ,表示这是一个文件而已；                    }                },                        module: {                    rules: [                        {                            test: /\\.js$/,                            include: [path.resolve(__dirname, '../src')],                            exclude: [path.resolve(__dirname, '../src/lib/jquery.min.js')],                            use: scriptLoader                        },                        {                            test: /\\.less$/,                                    use: styleLoader                        },                        {                            test: /\\.(png|jpg|jpeg|gif)$/,                            use: fileLoader.concat(                                env === 'production' ?                                    {                                        loader: 'img-loader'                                    }: []                            )                        },                        {                            test: path.resolve(__dirname, 'src/app.js'),                            use: [                                {                                    loader: 'imports-loader',                                    options: {                                        $: 'jquery'                                    }                                }                            ]                        },                        {                            test: /\\.html$/,                            use: [                                {                                    loader: 'html-loader',                                    options: {                                        attrs: ['img:src', 'img:data-src']                                    }                                }                            ]                        },                        {                            test: /\\.(eot|woff2|woff|ttf|svg)$/,                            use: [                                {                                    loader: 'url-loader',                                    options: {                                        limit: 1024 * 50,                                        fallback: {                                            loader: 'file-loader',                                            options: {                                                // useRelativePath: true,                                                publicPath: '../fonts',                                                outputPath: 'fonts',                                            }                                        }                                    }                                }                            ]                        }                    ]                },                        plugins: [                    extractLess,                            new HtmlWebpackPlugin({                        filename: 'index.html',                        template: './index.html',                        chunks: ['app'],                        minify: {                            collapseWhitespace: false                //祛除空格                        }                    }),                            new Webpack.ProvidePlugin({                        $: 'jquery'                    }),                ]            }        };                module.exports = env => {            let config = env === 'production' ? productionConfig : developmentConfig;                    return merge(generateConfig(env), config)        };        ```     2. webpack.dev.conf.js        ```webpack.dev.conf.js        const Webpack = require('webpack');        const Jarvis = require('webpack-jarvis');                module.exports = {            devtool: \"cheap-module-source-map\",                    devServer: {                port: 3000,                proxy: {                    '/': {                        target: 'http://localhost:3002',                        changeOrigin: true,                        logLevel: 'debug',                        pathRewrite: {                            '': '/api/'                        }                    }                },                hot: true,                hotOnly: true,            },                    plugins: [                        new Webpack.HotModuleReplacementPlugin(),                        new Webpack.NamedModulesPlugin(),                        new Jarvis({                    port: 3001                }),            ]        };        ```     3. webpack.prod.conf.js        ```webpack.prod.conf.js         const path = require('path');        const Webpack = require('webpack');        const PurifyCSS = require('purifycss-webpack');        const glob = require('glob-all');        const HtmlInlineChunkPlugin = require('html-webpack-inline-chunk-plugin');        const CleanWebpackPlugin = require('clean-webpack-plugin');                module.exports = {            plugins: [                new PurifyCSS({                    paths: glob.sync([                        path.join(__dirname, './*.html'),                        path.join(__dirname, './src/*.js')                    ]),                }),                                new Webpack.optimize.CommonsChunkPlugin({                    name: 'manifest'                }),                        new HtmlInlineChunkPlugin({                    inlineChunks: ['manifest']                }),                        new Webpack.optimize.UglifyJsPlugin(),                        new CleanWebpackPlugin(['dist']),            ]        };        ```     4. package.json        ```package.json          \"scripts\": {            \"server\": \"webpack-dev-server --env development --config build/webpack.common.conf.js\",            \"build\": \"webpack --env production --config build/webpack.common.conf.js\",          },        ```  ##### 使用middleware搭建开发环境  1. 使用middleware搭建开发环境     1. 安装middleware        ```bash         yarn add  express opn webpack-dev-middleware webpack-hot-middleware http-proxy-middleware connect-history-api-fallback --save-dev        ```  "},{title:"javascript进制转换",path:"/posts/javascript%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.html",strippedContent:' ## 进制分类  ### 二进制（逢二进一）  1.  ``1. 0、1``      - 以0b或者0B开头  ### 八进制（逢八进一）  1.  ``0、1、2、3、4、5、6、7``      - 以0开头        ### 十进制（逢十进一）  1.  ``0、1、2、3、4、5、6、7、8、9``  ### 十六进制（逢十六进一）  1.  ``0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F``      - 以0x或者0X开头    ## 进制转换  ### 10进制转其他进制  #### 10 进制转 2 进制  1. 除2取余，余数倒序  ```  var x = 2  console.log(x.toString(2))  ```  #### 10 进制转 8 进制  1. 除8取余，余数倒序  ```  var x = 9  console.log(x.toString(8))  ```  #### 10 进制转 16 进制  1. 除16取余，余数倒序  ```  var x = 17  console.log(x.toString(8))  ```  #### 10进制转N进制  1. 使用``parseInt``          -. 语法:``parseInt(x).toString(radix)``      ```javascript      parseInt("10").toString();\t\t\t    //返回 10（默认十进制）      parseInt("19").toString(10);\t\t    //返回 19      parseInt("11").toString(2);\t\t        //返回 1011      parseInt("17").toString(8);\t\t        //返回 21      parseInt("1f").toString(16);\t\t    //返回 1      parseInt("010").toString();             //返回 10（默认十进制）      parseInt("000010").toString(10);        //返回 10（默认十进制）      ```  ### 其他进制转10进制  1. 使用``parseInt``          -. 语法:``parseInt(string, radix);``      > string必需。要被解析的字符串。      > radix可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。               ```javascript      parseInt("10");\t\t\t//返回 10      parseInt("19",10);\t\t//返回 19 (10+9)      parseInt("11",2);\t\t//返回 3 (2+1)      parseInt("17",8);\t\t//返回 15 (8+7)      parseInt("1f",16);\t\t//返回 31 (16+15)      parseInt("010");        //返回 10（默认十进制）      parseInt("000010");     //返回 10（默认十进制）      ```  '},{title:"常用正则表达式",path:"/posts/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",strippedContent:' **- 校验数字的表达式**        1. 数字：^[0-9]*$      2. n位的数字：^\\d{n}$      3. 至少n位的数字：^\\d{n,}$      4. m-n位的数字：^\\d{m,n}$      5. 零和非零开头的数字：^(0|[1-9][0-9]*)$      6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$      7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$      8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$      9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$      10.有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$      11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$      12. 非零的负整数：^\\-[1-9][]0-9"*$ 或 ^-[1-9]\\d*$      13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$      14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$      15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$      16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$      17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$      18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$      19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$     **- 校验字符的表达式**        1. 汉字：^[\\u4e00-\\u9fa5]{0,}$      2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$      3. 长度为3-20的所有字符：^.{3,20}$      4. 由26个英文字母组成的字符串：^[A-Za-z]+$      5. 由26个大写英文字母组成的字符串：^[A-Z]+$      6. 由26个小写英文字母组成的字符串：^[a-z]+$      7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$      8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$      9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$      10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$      11. 可以输入含有^%&\',;=?$\\"等字符：[^%&\',;=?$\\x22]+      12. 禁止输入含有~的字符：[^~\\x22]+     **- 特殊需求表达式**        1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$      2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?      3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$      4. 手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\\d{8}$ (由于工信部放号段不定时，所以建议使用泛解析 ^([1][3,4,5,6,7,8,9])\\d{9}$)      5. 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$       6. 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}       7. 18位身份证号码(数字、字母x结尾)：^((\\d{18})|([0-9x]{18})|([0-9X]{18}))$      8. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$      9. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$      10. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$        11. 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}      12. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$      13. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$       14 钱的输入格式：         14-1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$          14-2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$          14-3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$          14-4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$          14-5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$          14-6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$          14-7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$          14-8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$          备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里      15. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$      16. 中文字符的正则表达式：[\\u4e00-\\u9fa5]      17. 双字节字符：[^\\x00-\\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))      18. 空白行的正则表达式：\\n\\s*\\r    (可以用来删除空白行)      19. HTML标记的正则表达式：<(\\S*?)[^>]*>.*?</\\1>|<.*? />    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)      20. 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)      21. 腾讯QQ号：[1-9][0-9]{4,}    (腾讯QQ号从10000开始)      22. 中国邮政编码：[1-9]\\d{5}(?!\\d)    (中国邮政编码为6位数字)      23. IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+    (提取IP地址时有用)      24. IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))    '},{title:"react-native知识点",path:"/posts/react-native%E7%9F%A5%E8%AF%86%E7%82%B9.html",strippedContent:' ## 1.React Native相对于原生的ios和Android有哪些优势？  1.性能媲美原生APP  2.使用JavaScript编码，只要学习这一种语言  3.绝大部分代码安卓和IOS都能共用  4.组件式开发，代码重用性很高  5.跟编写网页一般，修改代码后即可自动刷新，不需要慢慢编译，节省很多编译等待时间  6.支持APP热更新，更新无需重新安装APP    缺点：  内存占用相对较高  版本还不稳定，一直在更新，现在还没有推出稳定的1.0版本    ## 2.React Native组件的生命周期  ![](http://pic.yupoo.com/forrest071/dede824f/a0e072f5.jpg)    生命周期\t调用次数\t能否使用 setSate()  getDefaultProps\t1(全局调用一次)\t否  getInitialState\t1\t否  componentWillMount\t1\t是  render\t>=1\t否  componentDidMount\t1\t是  componentWillReceiveProps\t>=0\t是  shouldComponentUpdate\t>=0\t否  componentWillUpdate\t>=0\t否  componentDidUpdate\t>=0\t否  componentWillUnmount\t1\t否      ## 3.当你调用setState的时候，发生了什么事？  当调用 setState 时，React会做的第一件事情是将传递给 setState 的对象合并到组件的当前状态。  这将启动一个称为和解（reconciliation）的过程。  和解（reconciliation）的最终目标是以最有效的方式，根据这个新的状态来更新UI。  为此，React将构建一个新的 React 元素树（您可以将其视为 UI 的对象表示）。  一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React 会将这个新树与上一个元素树相比较（ diff ）。  通过这样做， React 将会知道发生的确切变化，并且通过了解发生什么变化，只需在绝对必要的情况下进行更新即可最小化 UI 的占用空间。    ## 4.props和state相同点和不同点  1.不管是props还是state的改变，都会引发render的重新渲染。  2.都能由自身组件的相应初始化函数设定初始值。    不同点  1.初始值来源：state的初始值来自于自身的getInitalState（constructor）函数；props来自于父组件或者自身getDefaultProps（若key相同前者可覆盖后者）。    2.修改方式：state只能在自身组件中setState，不能由父组件修改；props只能由父组件修改，不能在自身组件修改。    3.对子组件：props是一个父组件传递给子组件的数据流，这个数据流可以一直传递到子孙组件；state代表的是一个组件内部自身的状态，只能在自身组件中存在。    ## 5.shouldComponentUpdate 应该做什么  其实这个问题也是跟reconciliation有关系。  “和解（ reconciliation ）的最终目标是以最有效的方式，根据新的状态更新用户界面”。  如果我们知道我们的用户界面（UI）的某一部分不会改变，  那么没有理由让 React 很麻烦地试图去弄清楚它是否应该渲染。  通过从 shouldComponentUpdate 返回 false，  React 将假定当前组件及其所有子组件将保持与当前组件相同    ## 6.reactJS的props.children.map函数来遍历会收到异常提示，为什么？应该如何遍历？  this.props.children 的值有三种可能：      1.当前组件没有子节点，它就是 undefined;      2.有一个子节点，数据类型是 object ；      3.有多个子节点，数据类型就是 array 。  系统提供React.Children.map()方法安全的遍历子节点对象    ## 7.redux状态管理的流程  ![](http://pic.yupoo.com/forrest071/0f711f99/33431f36.png)  action是用户触发或程序触发的一个普通对象。  reducer是根据action操作来做出不同的数据响应，返回一个新的state。  store的最终值就是由reducer的值来确定的。（一个store是一个对象, reducer会改变store中的某些值）  action -> reducer -> 新store -> 反馈到UI上有所改变。      ## 8.加载bundle的机制  要实现RN的脚本热更新，我们要搞明白RN是如何去加载脚本的。 在编写业务逻辑的时候，我们会有许多个js文件，打包的时候RN会将这些个js文件打包成一个叫index.android.bundle(ios的是index.ios.bundle)的文件，所有的js代码(包括rn源代码、第三方库、业务逻辑的代码)都在这一个文件里，启动App时会第一时间加载bundle文件，所以脚本热更新要做的事情就是替换掉这个bundle文件。    ## 9.Flex布局  采用Flex布局的元素，称为Flex容器（flex Container），简称"容器"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称"项目"。  ![](http://pic.yupoo.com/forrest071/bd1d492f/2c0075a1.png)    容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。    项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。    容器的属性  以下6个属性设置在容器上。  flex-direction  属性决定主轴的方向（即项目的排列方向)。  flex-wrap   属性定义，如果一条轴线排不下，如何换行。  flex-flow   flex-flow属性是flex-direction属性和flex-wrap属性的简写形式。  justify-content   定义了项目在主轴上的对齐方式。  align-items  属性定义项目在交叉轴上如何对齐。  align-content  align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。    ## 10.请简述 code push 的原理  code push 调用 react native 的打包命令，将当前环境的非 native 代码全量打包成一个 bundle 文件，然后上传到微软云服务器（Windows Azure）。 在 app 中启动页（或 splash 页）编写请求更新的代码（请求包含了本地版本，hashCode、appToken 等信息），微软服务端对比本地 js bundle 版本和微软服务器的版本，如果本地版本低，就下载新的 js bundle 下来后实现更新(code push 框架实现)。    ## 11.Redux中同步 action 与异步 action 最大的区别是什么  同步只返回一个普通 action 对象。而异步操作中途会返回一个 promise 函数。当然在 promise 函数处理完毕后也会返回一个普通 action 对象。thunk 中间件就是判断如果返回的是函数，则不传导给 reducer，直到检测到是普通 action 对象，才交由 reducer 处理。        转载自 : [ react-native-interview](https://github.com/forrest23/react-native-interview " react-native-interview")      '},{title:"React知识点整理",path:"/posts/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86.html",strippedContent:" ## react组件内三大属性  1.``state``: 值为容器对象, 保存的是组件内可变的数据,组件根据``state``中的数据显示, 要更新界面只要更新``state``即可  2.``props``: 值为容器对象, 保存的是从组件外传递过来的数据, 当前组件只读, 父组件修改了自动显示新数据  3.``refs``: 值为容器对象, 保存的是``n``个有``ref``属性的``dom``元素对象, 属性名是``ref``指定的标识名称, 值为对应的``dom``元素    ## 组件内要注意的事项  1.组件内置的方法中的``this``为组件对象  2.在组件类中自定义的方法中``this``为``null``  a.强制绑定``this``: 通过函数对象的``bind()``  b.箭头函数(``ES6``模块化编码时才能使用)    ## 组件的生命周期(相应钩子函数)  ``constructor()``: 当创建组件对象时调用  ``componentWillMount()``: 可以为第一次``render()``调用, 做一些同步的准备工作  **``render()``**: 返回需要显示的虚拟``DOM``  **``componentDidMount()``**: 执行异步任务代码: 发``ajax``请求, 启动定时器, 绑定监听  ``componentWillUpdate()``: 更新之前  ``render()``: 重新渲染组件  ``componentDidUpdate()``: 更新之后  **``componentWillUnmount()``**: 死亡之前调用, 做一些收尾的工作  ** ``componentWillReceiveProps()``**: 监视接收到新的``props``, 发送``ajax``  加粗部分为重要的钩子函数    ## axios  1. GET请求  ```javascript  xios.get('/user?ID=12345')      .then(function (response) {          console.log(response);      })      .catch(function (error) {          console.log(error);      });  axios.get('/user', {      params: {        ID: 12345      }  })      .then(function (response) {          console.log(response);      })      .catch(function (error) {          console.log(error);      });  ```  2. POST请求  ```javascript  axios.post('/user', {      firstName: 'Fred',      lastName: 'Flintstone'  })  .then(function (response) {    console.log(response);  })  .catch(function (error) {    console.log(error);  });  ```  ## react-router相关  #### 组件  1. 路由的基本  2. 路由的基本有#一般用在  3. Route是路由的一个原材料，它是控制路径对应显示的组件。我们经常用的是exact、path以及component属性。  4.渲染时将导航到一个新地址，这个新地址覆盖在访问历史信息里面的本该访问的那个地址。  5.为你的应用提供声明式，无障碍导航。  6.这是 的特殊版，顾名思义这就是为页面导航准备的。因为导航需要有 “激活状态”。  7.只渲染出第一个与当前访问地址匹配的<0route>或。  #### history API  a.History.createBrowserHistory(): 得到封装window.history的管理对象  b.History.createHashHistory(): 得到封装window.location.hash的管理对象  c.history.push(): 添加一个新的历史记录  d.history.replace(): 用一个新的历史记录替换当前的记录  e.history.goBack(): 回退到上一个历史记录  f.history.goForword(): 前进到下一个历史记录  g.history.listen(function(location){}): 监视历史记录的变化    #### match location  match -> this.props.match.params.id(post请求)  location -> this.props.location.query.id(get请求)    1.query参数         路由的path: /xxx       请求的路径: /xxxname=tom&age=18       ?后面的部分就是quer参数: name=tom, age=18  2.param参数         路由的path: /xxx/:name/:age       请求的路径: /xxx/jack/18       param参数: name=jack,age=18       params.name, params.age    ## redux  #### 核心api  ##### createStore()        作用: 创建包含指定reducer的store对象  ##### store对象        redux库最核心的管理对象它内部维护着:state, reducer    ##### 核心方法:        getState() 返回应用当前的 state 树。它与 store 的最后一个 reducer 返回值相同。      dispatch(action) 分发 action。这是触发 state 变化的惟一途径。      subscribe(listener) 监听数据更新,从新渲染组件    ##### applyMiddleware()    1.作用:应用上基于redux的中间件(插件库)  2.编码:  ```javascript  import {createStore, applyMiddleware} from 'redux'  import thunk from 'redux-thunk'  // redux异步中间件  const store = createStore(    counter,    applyMiddleware(thunk) // 应用上异步中间件  )  ```  ##### combineReducers()  1.作用:合并多个reducer函数  2.编码:  ```javascript  export default combineReducers({      xxx,      yyy  })  ```    ## 三个核心概念  action:标识要执行行为的对象    reducer:根据老的state和action, 产生新的state的纯函数    store:将state,action与reducer联系在一起的对象    #### redux-react    ##### React-Redux将所有组件分成两大类  1.UI组件        a.只负责 UI 的呈现，不带有任何业务逻辑  \t        b.通过props接收数据(一般数据和函数)  \t      c.不使用任何 Redux 的 API      d.一般保存在components文件夹下  \t  2.容器组件        a.负责管理数据和业务逻辑，不负责UI的呈现      b.使用 Redux 的 API      c.一般保存在containers文件夹下    #### 相关API  ##### 1.Provider 让所有组件都可以得到state数据  ```javascript  <Provider store={store}>    <App />  </Provider>  ```  ##### 2.connect() 用于包装 UI 组件生成容器组件    #### 纯函数与高阶函数  ##### 纯函数  1. 一类特别的函数: 只要是同样的输入，必定得到同样的输出  2. 必须遵守以下一些约束  \ta.不得改写参数  \tb.不能调用系统 I/O 的API  \tc.能调用Date.now()或者Math.random()等不纯的方法  3. reducer函数必须是一个纯函数  ##### 高阶函数  4. 理解: 一类特别的函数  \ta.情况1: 参数是函数  \tb.情况2: 返回是函数  5. 常见的高阶函数:  \ta.定时器设置函数  \tb.数组的map()/filter()/reduce()/find()/bind()  \tc.react-redux中的connect函数  6. 作用:  \ta.能实现更加动态, 更加可扩展的功能  "},{title:"RxJava的优势",path:"/posts/RxJava%E7%9A%84%E4%BC%98%E5%8A%BF.html",strippedContent:' ## 案例对比    > 这是一个下载网络图片并且装载水印，然后显示到ImageView上的代码案例    #### 抽取公用代码    \tpublic class MainActivity extends AppCompatActivity {    \t    private ImageView mImageView;  \t    @Override  \t    protected void onCreate(Bundle savedInstanceState) {  \t        super.onCreate(savedInstanceState);  \t        setContentView(R.layout.activity_main);  \t        mImageView = (ImageView) findViewById(R.id.image);  \t    }  \t  \t\t// 给图片加水印的方法  \t    private Bitmap createWatermark(Bitmap bitmap, String mark) {  \t        int w = bitmap.getWidth();  \t        int h = bitmap.getHeight();  \t        Bitmap bmp = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  \t        Canvas canvas = new Canvas(bmp);  \t        Paint p = new Paint();  \t        // 水印颜色  \t        p.setColor(Color.parseColor("#C5FF0000"));  \t        // 水印字体大小  \t        p.setTextSize(150);  \t        //抗锯齿  \t        p.setAntiAlias(true);  \t        //绘制图像  \t        canvas.drawBitmap(bitmap, 0, 0, p);  \t        //绘制文字  \t        canvas.drawText(mark, 0, h / 2, p);  \t        canvas.save(Canvas.ALL_SAVE_FLAG);  \t        canvas.restore();  \t        return bmp;  \t    }  \t}    #### 没用 RxJava 之前        new Thread(new Runnable() {          @Override          public void run() {              try {                  URL url = new URL("https://www.baidu.com/img/bd_logo1.png?where=super");                  HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();                  InputStream inputStream = urlConnection.getInputStream();                  Bitmap bitmap = BitmapFactory.decodeStream(inputStream);                  // 加一个水印                  bitmap = createWatermark(bitmap,"RxJava2.0");                  // 显示到图片                  Message message = Message.obtain();                  message.obj = bitmap;                  mHandler.sendMessage(message);              } catch (IOException e) {                  e.printStackTrace();              }          }      }).start();        private Handler mHandler = new Handler(){          @Override          public void handleMessage(Message msg) {              Bitmap bitmap = (Bitmap) msg.obj;              mImageView.setImageBitmap(bitmap);          }      };    #### 使用 RxJava 之后    ```python  Observable.just("https://www.baidu.com/img/bd_logo1.png?where=super")    .map(new Function<String, Bitmap>() { // 事件变换          @Override        public Bitmap apply(@NonNull String urlPath) throws Exception {            URL url = new URL(urlPath);            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();            InputStream inputStream = urlConnection.getInputStream();            Bitmap bitmap = BitmapFactory.decodeStream(inputStream);            return bitmap;        }    })    .map(new Function<Bitmap, Bitmap>() {          @Override        public Bitmap apply(@NonNull Bitmap bitmap) throws Exception {            bitmap = createWatermark(bitmap, "RxJava2.0");            return bitmap;        }    })    .subscribeOn(Schedulers.io())    .observeOn(AndroidSchedulers.mainThread())    .subscribe(new Consumer<Bitmap>() {          @Override        public void accept(Bitmap bitmap) throws Exception {            mImageView.setImageBitmap(bitmap);        }    });  ```    #### RxJava 优势    * 实现优雅：链式调用，一点到底    * 逻辑简洁：代码可读性高，解耦    * 使用简单：支持线程调度和各种操作符    * 扩展维护：随着程序逻辑的复杂性提高，它依然能够保持简洁和优雅  '},{title:"Rxjava笔记",path:"/posts/rxjava%E7%AC%94%E8%AE%B02.html",strippedContent:' #### 添加依赖    \tcompile \'io.reactivex.rxjava2:rxandroid:2.0.1\'  \tcompile \'io.reactivex.rxjava2:rxjava:2.0.1\'    ---        compile \'io.reactivex.rxjava2:rxandroid:2.1.0\'      compile \'io.reactivex.rxjava2:rxjava:2.2.3\'    #### 创建数据源（被观察者/可观察者）    ###### just 方法    > 返回一个可观察对象，该对象发出给定(常量引用)项的信号，然后完成        Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)      .subscribe(new Consumer<Integer>() {          @Override          public void accept(Integer integer) throws Exception {              System.out.println("just：" + integer);          }      });    ---    \tjust：1  \tjust：2  \tjust：4  \tjust：5  \tjust：6  \tjust：7  \tjust：8  \tjust：9  \tjust：10    ###### fromArray 方法    > fromArray 和 Just 几乎是一样的效果，只不过 Just 限制 10 个以内，而 fromArray 并没有限制，查看得知 单个参数 Just 是自行创建 ObservableJust，而多个参数 Just 最终还是回调了 fromArray，这里不再过多演示    ###### create 方法        Observable.create(new ObservableOnSubscribe<Integer>() {            @Override          public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {              //执行多次              emitter.onNext(1);              emitter.onNext(2);              emitter.onNext(3);              //标记事件结束              emitter.onComplete();              //标记事件发送错误              //emitter.onError(new NullPointerException("不能为空"));          }      }).subscribe(new Consumer<Integer>() {            @Override          public void accept(Integer integer) throws Exception {              System.out.println("create：" + integer);          }      });    ---    \tcreate：1  \tcreate：2  \tcreate：3    ###### range 方法    > 使用范围数据，指定输出数据的范围（1-40的数值）        Observable.range(3, 5)      .subscribe(new Consumer<Integer>() {          @Override          public void accept(Integer integer) throws Exception {              System.out.println("range：" + integer);          }      });    ----    \trange：3  \trange：4  \trange：5  \trange：6  \trange：7    ###### interval 方法    > 指定某一时刻进行数据发送        Observable.interval(10, 1, TimeUnit.SECONDS) // 先等待 10 秒，之后再每一秒发送一次，10 秒这个参数也可以不填，默认用间隔时间参数替代（这里示例 1 秒）      .subscribe(new Consumer<Long>() {          @Override          public void accept(Long l) throws Exception {              System.out.println("interval：" + l);          }      });    ---    \t2019-03-20 15:30:33.331 interval：0  \t2019-03-20 15:30:34.331 interval：1  \t2019-03-20 15:30:35.331 interval：2  \t2019-03-20 15:30:36.331 interval：3  \t2019-03-20 15:30:37.331 interval：4  \t2019-03-20 15:30:38.331 interval：5  \t..................................    #### 创建事件的接收者（观察者|订阅者），onNext方法中的数据类型必须被观察者指定的泛型    \t// 表示观察者不对被观察者发送的事件作出任何响应（但被观察者还是可以继续发送事件）      public final Disposable subscribe() {}            // 表示观察者只对被观察者发送的Next事件作出响应      public final Disposable subscribe(Consumer<? super T> onNext) {}        // 表示观察者只对被观察者发送的Next事件 & Error事件作出响应      public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {}     \t// 表示观察者只对被观察者发送的Next事件、Error事件 & Complete事件作出响应      public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {}        \t// 表示观察者只对被观察者发送的Next事件、Error事件 、Complete事件 & onSubscribe事件作出响应      public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Consumer<? super Disposable> onSubscribe) {}        \t// 表示观察者对被观察者所有的事件做出响应      public final void subscribe(Observer<? super T> observer) {}    ###### Observer 类用法    > onSubscribe：订阅的时候被调用，方法参数有 Disposable，可用于取消订阅    > onNext(T item)：Observable调用这个方法发射数据，方法的参数就是Observable发射的数据，这个方法可能会被调用多次，取决于业务逻辑    > onCompleted()：正常终止，在没有遇到错误的情况下，Observable在最后一次调用onNext之后调用此方法    > onError(Throwable e)：当Observable遇到错误或者无法返回期望的数据时会调用这个方法，这个调用会终止Observable，后续不会再调用onNext和onCompleted，onError方法的参数是抛出异常        //观察者      Observable.just(1, 2, 3)      .subscribe(new Observer<Integer>() {            @Override          public void onSubscribe(Disposable d) {              System.out.println("onSubscribe");          }            @Override          public void onNext(Integer integer) {              System.out.println("onNext：" + integer);          }            @Override          public void onError(Throwable e) {              System.out.println("onError：" + e.toString());          }            @Override          public void onComplete() {              System.out.println("onComplete");          }      });    ---    \tonSubscribe  \tonNext：1  \tonNext：2  \tonNext：3  \tonComplete    ###### Consumer 类用法        Observable.just(1, 2, 3)      .subscribe(new Consumer<Integer>() {          @Override          public void accept(Integer integer) throws Exception {              System.out.println("accept：" + integer);          }      });    ---    \taccept：1  \taccept：2  \taccept：3    #### 订阅    \t// 订阅事件，被观察者必须指定了事件的接收者（观察者），整个事件流程才可以被启动  \tDisposable disposable = observable.subscribe(observer);    ---    \t// 是否被订阅  \tdisposable.isDisposed();    ---    \t// 取消订阅  \tdisposable.dispose();  '},{title:"Rxjava的线程调度",path:"/posts/Rxjava%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6.html",strippedContent:' #调度器    > 用于线程调度    ####使用案例    \tObservable.create(new Observable.OnSubscribe<String>() {  \t\t\t  \t\t@Override  \t\tpublic void call(Subscriber<? super String> subscriber) {  \t\t\tSystem.out.println("正在进行耗时操作");  \t\t\tsubscriber.onNext("执行耗时操作后的结果");  \t\t\tsubscriber.onCompleted();  \t\t}  \t})  \t.subscribeOn(Schedulers.io())\t\t\t\t//让被观察者执行在IO线程  \t.observeOn(AndroidSchedulers.mainThread())\t//让观察者执行在主线程  \t.subscribe(...);    ####调度类型    * Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler    * Schedulers.newThread(): 总是启用新线程，并在新线程执行操作    * Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程    * Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU    * AndroidSchedulers.mainThread(): 它指定的操作将在 Android 主线程运行    > 有了这几个Scheduler，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。observeOn() 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。 observeOn() 的多次调用，程序实现了线程的多次切换。不过，不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次    > subscribeOn()：可执行多次，指定事件源或操作符执行的线程，叫做事件产生的线程。代码一般放在之前，除了事件源    > observeOn()：只执行一次，指定事件的接收者所运行在的线程。叫做事件消费的线程  '},{title:"Rxjava笔记",path:"/posts/Rxjava%E7%AC%94%E8%AE%B0.html",strippedContent:' #### 使用步骤    > build.gradle引入依赖    \tcompile \'io.reactivex:rxjava:1.0.14\'   \tcompile \'io.reactivex:rxandroid:1.0.1\'     #### 创建数据源（被观察者/可观察者），泛型必须是Object的子类    \tObservable observable = Observable.create(new Observable.OnSubscribe<String>() {  \t\t  \t\t//事件源，可以指定  \t\t@Override  \t\tpublic void call(Subscriber<? super String> subscriber) {  \t\t\t//执行多次  \t\t\tsubscriber.onNext("第一次执行");  \t\t\tsubscriber.onNext("第二次执行");  \t\t\t//标记事件结束  \t\t\tsubscriber.onCompleted();  \t\t\t//标记事件发送错误  \t\t\t//subscriber.onError();  \t\t}  \t});    ---    \t//from(T[])，返回的对象一般都是数值类型  \tInteger[] items = {1, 2, 3, 4, 5, 6, 7, 8, 9};  \tObservable observable = Observable.from(items);    ---    \t//指定某一时刻进行数据发送  \tObservable observable = Observable.interval(1, 1, TimeUnit.SECONDS);//每隔一秒发送数据    ---    \t//just(T...)，处理任意类型的数组集合或数值，参数上限10个，参数类型必须一致  \tInteger[] items1 = {1, 2, 3, 4, 5, 6};  \tInteger[] items2 = {3, 5, 6, 8, 3, 8};  \tObservable observable = Observable.just(items1, items2);    ---    \t//使用范围数据，指定输出数据的范围（1-40的数值）  \tObservable observable = Observable.range(1, 40);    ####创建事件的接收者（观察者|订阅者），onNext方法中的数据类型必须被观察者指定的泛型    > onNext(T item)：Observable调用这个方法发射数据，方法的参数就是Observable发射的数据，这个方法可能会被调用多次，取决于业务逻辑    > onCompleted()：正常终止，在没有遇到错误的情况下，Observable在最后一次调用onNext之后调用此方法    > onError(Throwable e)：当Observable遇到错误或者无法返回期望的数据时会调用这个方法，这个调用会终止Observable，后续不会再调用onNext和onCompleted，onError方法的参数是抛出异常    \tObserver<String> observer = new Observer<String>() {    \t\t@Override  \t\tpublic void onNext(String s) {  \t\t\tSystem.out.println("onNext" + s);  \t\t}  \t\t  \t\t@Override  \t\tpublic void onCompleted() {  \t\t\tSystem.out.println("onCompleted");  \t\t}  \t\t  \t\t@Override  \t\tpublic void onError(Throwable e) {  \t\t\tSystem.out.println("onError" + e.getMessage());  \t\t}  \t};    ---    \t//订阅者  \tSubscriber<String> subscriber = new Subscriber<String>() {    \t\t@Override  \t\tpublic void onStart(String s) {  \t\t\tSystem.out.println("事件开始了");  \t\t}    \t\t@Override  \t\tpublic void onNext(String s) {  \t\t\tSystem.out.println("onNext" + s);  \t\t}  \t\t  \t\t@Override  \t\tpublic void onCompleted() {  \t\t\tSystem.out.println("onCompleted");  \t\t}  \t\t  \t\t@Override  \t\tpublic void onError(Throwable e) {  \t\t\tSystem.out.println("onError" + e.getMessage());  \t\t}  \t};      ---    \t//对订阅者进行简化，更简单  \tAction1<String> action1 = new Action1<String>() {    \t\t@Override  \t\tpublic void call(String s) {  \t\t\tSystem.out.println("call" + s);  \t\t}  \t};    #### 订阅事件，被观察者必须指定了事件的接收者（观察者|订阅者），整个事件流程才可以被启动    \tobservable.subscribe(observer);    ---    \tobservable.subscribe(subscriber);    ---    \t//选择性参数方法，可对onNext，onCompleted，onError选择性使用，一般只需要onNext方法就足够  \tobservable.subscribe(action1);    \t//自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()  \tobservable.subscribe(onNextAction);  \t//自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()  \tobservable.subscribe(onNextAction, onErrorAction);  \t//自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()  \tobservable.subscribe(onNextAction, onErrorAction, onCompletedAction);    \t简单解释一下这段代码中出现的 Action1 和 Action0。   \tAction0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；  \t由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。  \t这样其实也可以看做将 onCompleted() 方法作为参数传进了 subscribe()，相当于其他某些语言中的『闭包』。  \tAction1 也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；  \t与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。  \t事实上，虽然 Action0 和 Action1 在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法    > 订阅者是观察者的子类，区别在于订阅者可以取消订阅（在程序销毁后）    \tif(subscriber != null && !subscriber.isUnsubscribed()) {  \t\tsubscriber.unsubscribe();  \t}    '},{title:"Android Studio或VSCode在第三方模拟器上运行flutter项目",path:"/posts/Android%20Studio%E6%88%96VSCode%E5%9C%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8Cflutter%E9%A1%B9%E7%9B%AE.html",strippedContent:" 1. 先打开夜神模拟器  1. `win+R`选择`cmd`进入第三方模拟器的安装目录的`bin`目录下  1. `adb connect 127.0.0.1:62001`  1. `VSCode `命令行或 `Android Studio` 命令行中执行`flutter`项目启动命令。```  `flutter run`  ```  ![cmd.png](https://i.w4ctech.cn/usr/uploads/2019/03/1524769841.png)  ![cmd.png](https://i.w4ctech.cn/usr/uploads/2019/03/3683161917.png)    一键启动夜神模拟器方法：  1. 桌面新建openyeshen.文本文档  2. 写入  ```bash  d:  cd yeshen  cd Nox  cd bin  adb connect 127.0.0.1:62001  ```  3. 保存退出将文件名后缀改为cmd  "},{title:"Rxjava中的操作符",path:"/posts/Rxjava%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6.html",strippedContent:' #### map 转换    > map转换，将泛型指定的对象转换成其他类型的对象，可进行多次转换        Observable.create(new ObservableOnSubscribe<String>() {            @Override          public void subscribe(ObservableEmitter<String> emitter) throws Exception {              emitter.onNext("100");              emitter.onComplete();          }        }).map(new Function<String, Integer>() {            @Override          public Integer apply(String s) throws Exception {              return Integer.valueOf(s);          }        }).subscribe(new Consumer<Integer>() {                    @Override          public void accept(Integer integer) throws Exception {              System.out.println("这里就已经将 String 转换成 Integer 了" + integer);          }      });    ---    \t这里就已经将 String 转换成 Integer了100    #### filter 过滤    > filter过滤，将指定的对象过滤掉，可进行多次过滤    ```dart  Observable.just(1, 2, 3, 4, 5, 7, 8)  .filter(new Predicate<Integer>() {        @Override      public boolean test(Integer integer) throws Exception {          //大于5的过滤掉          return integer < 5;      }  })  .subscribe(new Consumer<Integer>() {        @Override      public void accept(Integer integer) throws Exception {          System.out.println("这里就能获取到过滤后的整数了" + integer);      }  });  ```    ---    \t这里就能获取到过滤后的整数了1  \t这里就能获取到过滤后的整数了2  \t这里就能获取到过滤后的整数了3  \t这里就能获取到过滤后的整数了4    #### flatMap 平铺    > flatMap平铺，一对多的转化（类似嵌套），这里需要注意的是, flatMap并不保证事件的顺序, 如果需要保证顺序则需要使用concatMap    ```dart  Observable.create(new ObservableOnSubscribe<Integer>() {        @Override      public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {          emitter.onNext(1);          emitter.onNext(2);          emitter.onNext(3);      }    }).flatMap(new Function<Integer, ObservableSource<String>>() {        @Override      public ObservableSource<String> apply(Integer integer) throws Exception {            final List<String> list = new ArrayList<>();          for (int i = 0; i < 3; i++) {              list.add("I am value " + integer);          }          return Observable.fromIterable(list).delay(10, TimeUnit.MILLISECONDS);      }    }).subscribe(new Consumer<String>() {        @Override      public void accept(String s) throws Exception {          System.out.println("TAG：" + s);      }  });    ```  ---    \tD/TAG: I am value 1  \tD/TAG: I am value 1  \tD/TAG: I am value 1  \tD/TAG: I am value 3  \tD/TAG: I am value 3  \tD/TAG: I am value 3  \tD/TAG: I am value 2  \tD/TAG: I am value 2  \tD/TAG: I am value 2    #### distinct 去重复    ```dart  Observable.just(1, 1, 2, 2, 3, 3)  .distinct()  .subscribe(new Consumer<Integer>() {      @Override      public void accept(Integer integer) throws Exception {          System.out.println("这里就能获取去重复之后的整数了：" + integer);      }  });  ```    ---    \t这里就能获取去重复之后的整数了：1  \t这里就能获取去重复之后的整数了：2  \t这里就能获取去重复之后的整数了：3    #### take 取出固定个数    ```dart  Observable.just(1, 2, 3, 4, 5, 6)  .take(2)  .subscribe(new Consumer<Integer>() {      @Override      public void accept(Integer integer) throws Exception {          System.out.println("这里就能取出固定个数之后的整数了：" + integer);      }  });  ```    ---    \t这里就能取出固定个数之后的整数了：1  \t这里就能取出固定个数之后的整数了：2  \t这里就能取出固定个数之后的整数了：3    #### toList 打包成集合    ```dart  Observable.just(1, 2, 3, 4, 5, 6)  .toList()  .subscribe(new Consumer<List<Integer>>() {      @Override      public void accept(List<Integer> integers) throws Exception {          System.out.println("这里可以直接打包成一个集合，集合的长度为" + integers.size());      }  });  ```    ---    \t这里可以直接打包成一个集合，集合的长度为6    #### delay 延迟    > 使得被观察者延迟一段时间再发送事件    \t// 1. 指定延迟时间  \t// 参数1 = 时间；参数2 = 时间单位  \tdelay(long delay,TimeUnit unit)  \t  \t// 2. 指定延迟时间 & 调度器  \t// 参数1 = 时间；参数2 = 时间单位；参数3 = 线程调度器  \tdelay(long delay,TimeUnit unit,mScheduler scheduler)  \t  \t// 3. 指定延迟时间  & 错误延迟  \t// 错误延迟，即：若存在Error事件，则如常执行，执行后再抛出错误异常  \t// 参数1 = 时间；参数2 = 时间单位；参数3 = 错误延迟参数  \tdelay(long delay,TimeUnit unit,boolean delayError)  \t  \t// 4. 指定延迟时间 & 调度器 & 错误延迟  \t// 参数1 = 时间；参数2 = 时间单位；参数3 = 线程调度器；参数4 = 错误延迟参数  \tdelay(long delay,TimeUnit unit,mScheduler scheduler,boolean delayError): 指定延迟多长时间并添加调度器，错误通知可以设置是否延迟    ---    ```dart  Observable.just(1, 2, 3)  .delay(3, TimeUnit.SECONDS) // 延迟3s再发送，由于使用类似，所以此处不作全部展示  .subscribe(new Consumer<Integer>() {      @Override      public void accept(Integer integer) throws Exception {          System.out.println("延迟测试" + integer);      }  });  ```    #### zip 压合    > [给初学者的RxJava2.0教程(四)](https://www.jianshu.com/p/bb58571cdb64)    > 将两个被观察者对象组合成一个，如果两个被观察者的大小不同，合并的次数将以最小那个为主    \tObservable<Integer> observable1 = Observable.create(new ObservableOnSubscribe<Integer>() {                \t    @Override                                                                                           \t    public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {                        \t        Log.d(TAG, "emit 1");                                                                           \t        emitter.onNext(1);                                                                              \t        Log.d(TAG, "emit 2");                                                                           \t        emitter.onNext(2);                                                                              \t        Log.d(TAG, "emit 3");                                                                           \t        emitter.onNext(3);                                                                              \t        Log.d(TAG, "emit 4");                                                                           \t        emitter.onNext(4);                                                                              \t        Log.d(TAG, "emit complete1");                                                                   \t        emitter.onComplete();                                                                           \t    }                                                                                                   \t});                                                                     \t                                                                                                        \tObservable<String> observable2 = Observable.create(new ObservableOnSubscribe<String>() {                \t    @Override                                                                                           \t    public void subscribe(ObservableEmitter<String> emitter) throws Exception {                         \t        Log.d(TAG, "emit A");                                                                           \t        emitter.onNext("A");                                                                            \t        Log.d(TAG, "emit B");                                                                           \t        emitter.onNext("B");                                                                            \t        Log.d(TAG, "emit C");                                                                           \t        emitter.onNext("C");                                                                            \t        Log.d(TAG, "emit complete2");                                                                   \t        emitter.onComplete();                                                                           \t    }                                                                                                   \t});                                                                       \t                                                                                                        \tObservable.zip(observable1, observable2, new BiFunction<Integer, String, String>() {                     \t    @Override                                                                                           \t    public String apply(Integer integer, String s) throws Exception {                                   \t        return integer + s;                                                                             \t    }).subscribe(new Observer<String>() {                         \t    @Override                                                                                           \t    public void onSubscribe(Disposable d) {                                                             \t        Log.d(TAG, "onSubscribe");                                                                      \t    }                                                                                                   \t                                                                                                        \t    @Override                                                                                           \t    public void onNext(String value) {                                                                  \t        Log.d(TAG, "onNext: " + value);                                                                 \t    }                                                                                                   \t                                                                                                        \t    @Override                                                                                           \t    public void onError(Throwable e) {                                                                  \t        Log.d(TAG, "onError");                                                                          \t    }                                                                                                   \t                                                                                                        \t    @Override                                                                                           \t    public void onComplete() {                                                                          \t        Log.d(TAG, "onComplete");                                                                       \t    }                                                                                                   \t});    ---    \tD/TAG: onSubscribe       \tD/TAG: emit 1            \tD/TAG: emit 2            \tD/TAG: emit 3            \tD/TAG: emit 4            \tD/TAG: emit complete1    \tD/TAG: emit A            \tD/TAG: onNext: 1A        \tD/TAG: emit B            \tD/TAG: onNext: 2B        \tD/TAG: emit C            \tD/TAG: onNext: 3C        \tD/TAG: emit complete2    \tD/TAG: onComplete    > 执行的顺序是第一个被观察者全部执行完毕之后才执行第二个被观察者对象，导致这种现象是因为他们都在同一个线程中，现在进行一下线程调度    \tObservable<Integer> observable1 = Observable.create(new ObservableOnSubscribe<Integer>() {           \t    @Override                                                                                        \t    public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {                     \t        Log.d(TAG, "emit 1");                                                                        \t        emitter.onNext(1);                                                                           \t                                                                                                     \t        Log.d(TAG, "emit 2");                                                                        \t        emitter.onNext(2);                                                                           \t                                                                                                     \t        Log.d(TAG, "emit 3");                                                                        \t        emitter.onNext(3);                                                                           \t                                                                                                     \t        Log.d(TAG, "emit 4");                                                                        \t        emitter.onNext(4);                                                                           \t                                                                                                     \t        Log.d(TAG, "emit complete1");                                                                \t        emitter.onComplete();                                                                        \t    }                                                                                                \t}).subscribeOn(Schedulers.io());                                                                     \t                                                                                                     \tObservable<String> observable2 = Observable.create(new ObservableOnSubscribe<String>() {             \t    @Override                                                                                        \t    public void subscribe(ObservableEmitter<String> emitter) throws Exception {                      \t        Log.d(TAG, "emit A");                                                                        \t        emitter.onNext("A");                                                                         \t                                                                                                     \t        Log.d(TAG, "emit B");                                                                        \t        emitter.onNext("B");                                                                         \t                                                                                                     \t        Log.d(TAG, "emit C");                                                                        \t        emitter.onNext("C");                                                                         \t                                                                                                     \t        Log.d(TAG, "emit complete2");                                                                \t        emitter.onComplete();                                                                        \t    }                                                                                                \t}).subscribeOn(Schedulers.io());                                                                     \t                                                                                                     \tObservable.zip(observable1, observable2, new BiFunction<Integer, String, String>() {                 \t    @Override                                                                                        \t    public String apply(Integer integer, String s) throws Exception {                                \t        return integer + s;                                                                          \t    }                                                                                                \t}).subscribe(new Observer<String>() {                      \t    @Override                                                                                        \t    public void onSubscribe(Disposable d) {                                                          \t        Log.d(TAG, "onSubscribe");                                                                   \t    }                                                                                                \t                                                                                                     \t    @Override                                                                                        \t    public void onNext(String value) {                                                               \t        Log.d(TAG, "onNext: " + value);                                                              \t    }                                                                                                \t                                                                                                     \t    @Override                                                                                        \t    public void onError(Throwable e) {                                                               \t        Log.d(TAG, "onError");                                                                       \t    }                                                                                                \t                                                                                                     \t    @Override                                                                                        \t    public void onComplete() {                                                                       \t        Log.d(TAG, "onComplete");                                                                    \t    }                                                                                                \t});         ---    \tD/TAG: onSubscribe      \tD/TAG: emit A           \tD/TAG: emit 1           \tD/TAG: onNext: 1A       \tD/TAG: emit B           \tD/TAG: emit 2           \tD/TAG: onNext: 2B       \tD/TAG: emit C           \tD/TAG: emit 3           \tD/TAG: onNext: 3C       \tD/TAG: emit complete2   \tD/TAG: onComplete       '},{title:"flutter自定义主题",path:"/posts/flutter%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98.html",strippedContent:" ```  import 'package:flutter/material.dart';  import 'package:flutter/foundation.dart';    void main(){    runApp(new MyApp());  }    class MyApp extends StatelessWidget {    @override    Widget build(BuildContext context) {      final appName = \"自定义主题\";      return  new MaterialApp(        title:appName,        theme: new ThemeData(          brightness: Brightness.light,//应用程序整体主题的亮度          primaryColor: Colors.lightGreen[600], //app主要部分的背景色          accentColor: Colors.orange[600], //前景色 （文本按钮）      ),        home: new MyHomePage(          title:appName        ),      );    }  }    class MyHomePage extends StatelessWidget {    final String title;    MyHomePage({Key key, this.title}) : super(key: key);    @override    Widget build(BuildContext context) {      return new Scaffold(        appBar: new AppBar(          title: new Text(title),        ),        body: new Center(          child: new Container(            color: Theme.of(context).accentColor,            child: new Text(              '带有背景色的文本组件',              style:Theme.of(context).textTheme.title,            ),          ),        ),        floatingActionButton: new Theme(          data: Theme.of(context).copyWith(accentColor: Colors.yellow),          child: new FloatingActionButton(            onPressed: null,            child: new Icon(Icons.compare),          ),        ),      );    }  }  ```    ![flutter-theme.png](https://i.loli.net/2019/03/13/5c88f0040dede.png)      **如果在应用程序的某一部分使用特殊颜色，需要覆盖全局主题。有两种方法可以解决这个需求。**    1. 创建特有的主题数据  ```    new MaterialApp(        title:appName,        theme: new ThemeData(          brightness: Brightness.light,//应用程序整体主题的亮度          primaryColor: Colors.lightGreen[600], //app主要部分的背景色          accentColor: Colors.orange[600], //前景色 （文本按钮）      ),        home: new MyHomePage(          title:appName        ),      );  ```  1. 扩展父主题  ```   \tnew Theme(          data: Theme.of(context).copyWith(accentColor: Colors.yellow),          child: new FloatingActionButton(            onPressed: null,            child: new Icon(Icons.compare),          ),        ),  ```      定义主题后，都需要用`Theme.of(content)`通过上下文获取主题。方法是查找最近的主题，如果找不到，就会找整个应用的主题。    相关链接：  [Theme.of](https://flutterchina.club/cookbook/design/themes/ \"Theme.of\")  "},{title:"vue兄弟组件通信不使用vuex",path:"/posts/vue%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B8%8D%E4%BD%BF%E7%94%A8.html",strippedContent:" 1. App.vue        ```      <template>          <div id=\"app\">              <showregister></showregister>              <register></register>          </div>      </template>        <script>          import register from './components/register';          import showregister from  './components/showregister';          export default {              name: 'app',              components: {                  showregister,                  register              }          };      <\/script>        <style scoped>      </style>      ```     2. eventBus.js        ```      import Vue from 'vue';      export default new Vue({});      ```   3. showregister.vue        ```      <template>          <div>              <button @click.stop.prevent=\"showregister\">showregister</button>          </div>      </template>        <script>          import eventBus from './eventBus';          export default {              name: 'showregister',              methods: {                  showregister: function () {                      eventBus.$emit('click');                  }              }          };      <\/script>        <style scoped>      </style>      ```     4. register.vue        ```      <template>          <div v-show=\"showModel\">              registerModel          </div>      </template>      <script>          import eventBus from './eventBus';          export default {              name: 'register',              data() {                  return {                      showModel: true                  };              },              created() {                  eventBus.$on('click', () => {                      this.showModel = true;                  });              }          };      <\/script>      <style scoped>      </style>      ```    "},{title:"flutter中get请求中返回451的解决方法",path:"/posts/flutter%E4%B8%ADget%E8%AF%B7%E6%B1%82%E4%B8%AD%E8%BF%94%E5%9B%9E451%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html",strippedContent:' ### **现象**  - 使用`Dio`库在访问api的时候返回``451``状态码    >  451状态码在计算机网上领域中，HTTP 451 因法律原因不可用（英语：HTTP 451 Unavailable For Legal Reasons）是一种HTTP协议的错误状态代码，当用户请求访问某个经政府审核等查核方法后认定不合法的来源时，就会显示这个错误代码。    ![451.jpg](https://i.w4ctech.cn/usr/uploads/2019/02/2696732492.jpg)    ### **解决方法**  封装一个请求头并引入。  找到``Request Headers``  ![newall.png](https://i.w4ctech.cn/usr/uploads/2019/02/40015677.png)。  并将``Request Headers``里的所有内容复制粘贴进新建立的``httpHeaders.dart``文件里，![httpHeaders.png](https://i.w4ctech.cn/usr/uploads/2019/02/1296327705.png)。    在``home_page.dart``中引入``httpHeaders.dart``文件。  在``getHttp()``方法里添加``dio.options.headers= httpHeaders;``  ![succese.png](https://i.w4ctech.cn/usr/uploads/2019/02/1051544378.png)    目测可以通过封装请求的方法可以通用。    相关链接：[Dio库中的Cookie管理](https://juejin.im/post/5b04c954f265da0b9c10fb61#heading-25 "Dio库中的Cookie管理")  '},{title:"解决flutter外部容器在键盘弹起时越界的两种方法",path:"/posts/%E8%A7%A3%E5%86%B3flutter%E5%A4%96%E9%83%A8%E5%AE%B9%E5%99%A8%E5%9C%A8%E9%94%AE%E7%9B%98%E5%BC%B9%E8%B5%B7%E6%97%B6%E8%B6%8A%E7%95%8C%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95.html",strippedContent:" # **1. 现象**    ![transboundary.gif](https://i.w4ctech.cn/usr/uploads/2019/02/725384706.gif)    # 2. 解决方法    - 在``rerutn Scaffold``中添加 ``resizeToAvoidBottomPadding: false,``![resizeToAvoidBottomPadding.jpg](https://i.w4ctech.cn/usr/uploads/2019/02/1684860450.jpg)    - 使用``SingleChildScrollView``  ![SingleChildScrollView.png](https://i.w4ctech.cn/usr/uploads/2019/02/3668625540.png)  "},{title:"Android Studio 自动更新失败解决办法",path:"/posts/Android%20Studio%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html",strippedContent:" 1.记事本打开``studio64.exe.vmoptions``文件。 新增              Djava.net.preferIPv4Stack=true       -Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml       -Didea.patches.url=http://dl.google.com/android/studio/patches/      2.如果重启后仍然更新失败。将url里的修改http为https，修改Android Studio设置``Preferences -> HTTP Proxy``。从``No Proxy``改成``Auto-detect proxy settings``。然后重启点击Check Update。     "},{title:"vim 学习笔记",path:"/posts/vim%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",strippedContent:" ### 启动 / 关闭 Vim  ## 启动  | 命令\t| 作用 |   | ------ | ------ |  | ``vim <file>``\t| 使用 Vim 打开某文件|     ## 退出  以下命令在 Vim 的控制模式下使用。    | 命令\t| 作用|   | ------ | ------ | ------ |  | :q!\t| 抛弃修改并退出|   | ZQ\t| 抛弃修改并退出 (alias)|   | :wq\t| 保存并退出|   | ZZ\t| (alias)|     ## 挂起  ## 通过 Vim 命令  | 命令\t| 作用|   | ------ | ------ | ------ |  | :!{cmd}\t| 用来执行某一条 shell 命令。如 :!cat database.conf|   | :sh\t| 进入 shell 环境。执行结束需要返回 Vim 编辑环境时，输入 exit 或按下 ctrl + d 即可|   ## 通过 Shell 命令  利用 Linux 作业机制，按下 ctrl + z 将当前程序放在后台执行。然后使用 fg 命令重新回到 Vim 编辑器。  详情参考Unix或Linux中&、jobs、fg、bg等命令的使用方法    ## 光标移动、复制粘贴、搜索替换  ## 光标移动  | 按键| \t作用|   | ------ | ------ | ------ |  | h ←| \t向左移动一个字符|   | l →| \t向右移动一个字符|   | j ↓| \t向下移动一行|   | k ↑| \t向上移动一行|       这四个键在键盘上是排列到一起的      | ------ | ------ | ------ |  | ctrl + b | 向上翻一整页 (backward) |  | ctrl + f | 向下翻一整页 (forward) |  | ctrl + u | 向上翻半页 (up) |  | ctrl + d | 向下翻半页 (down) |  | ctrl + y | 向上滚一行 |  | ctrl + e | 向下滚一行 |  | zz | 让光标所在行居于屏幕中央 |  | zt | 让光标所在行居于屏幕顶部 |  | zb | 让光标所在行居于屏幕底部 |    ## 搜索  ## 取消搜索高亮显示  | 命令\t| 作用|   | ------ | ------ | ------ |  | :nohighlight| \t取消搜索高亮显示|   | :nohl| \t取消搜索高亮显示 (alias)|     "},{title:"Flutter开发环境搭建",path:"/posts/Flutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",strippedContent:" ## 安装Flutter ##     1.  ``git clone https://github.com/flutter/flutter.git``   2.  在系统变量``path``新增 ``E:\\flutter\\bin``   3.  新增``PUB_HOSTED_URL``系统变量``https://pub.flutter-io.cn``   4.  新增`` FLUTTER_STORAGE_BASE_URL``系统变量``https://storage.flutter-io.cn``   5.  ``cd flutter``   6.  ``flutter doctor``      ![请输入图片描述][1]    ## ``Flutter``开发必备其他环境 ##     1. Java Jdk [https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html][2]   2. Android Studio [https://developer.android.com/studio/][3]   3. Git [https://git-scm.com/download/win][4]  ## 添加``Flutter``插件 ##     1. 打开``Android Stuido``,然后找到``Plugin``的配置，搜索``Flutter``和``Dart``插件并安装。        [Flutter填坑全面总结][5]    相关链接  ----     - Flutter源码链接 https://github.com/flutter/flutter   - Flutter官方文档 https://flutter.io/docs/   - Flutter中文文档 http://doc.flutter-dev.cn/   - Flutter中文社区 [https://flutter-io.cn/)   - Dart语言官方主页 https://www.dartlang.org/   - Dart语言中文社区 http://www.cndartlang.com/   - Dart中文官网 https://www.dart-china.org/   - Dark2 中文文档 https://www.kancloud.cn/marswill/dark2_document/709090         [1]: https://i.w4ctech.cn/usr/uploads/2019/01/2422904817.png    [2]: https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html    [3]: https://developer.android.com/studio/    [4]: https://git-scm.com/download/win    [5]: https://www.jianshu.com/p/22675c1632dc  "},{title:"那么爱立flag，你一定是积极废人吧！",path:"/posts/%E9%82%A3%E4%B9%88%E7%88%B1%E7%AB%8Bflag%EF%BC%8C%E4%BD%A0%E4%B8%80%E5%AE%9A%E6%98%AF%E7%A7%AF%E6%9E%81%E5%BA%9F%E4%BA%BA%E5%90%A7.html",strippedContent:" 公众号一条在文章《那么爱立flag，你一定是积极废人吧！》里，提出了“积极废人”的人设：    ![这三种思维，正在让你变成“积极废人”](https://pic.36krcnd.com/201805/23091456/p5jeobvyqlasr3rc)    网友表示：间歇性踌躇满志，持续性混吃等死，是我本人没错了。    “积极废人”也成为自“佛系青年”、“隐形贫困人口”后，又一个迅速火起来的词。    积极废人最大的特点是：口头上积极乐观，行动力却永远跟不上；制定过无数美好计划，能坚持下来的却屈指可数。    这其实反映的是多数年轻人身上的懒散和惰性。    而表面上的行为懒惰，实际上是受到惰性思维的左右。    **思维的的惰性，比行为上的懒惰更可怕，**因为坏的思维可以毁灭一个人。    《谁动了你的能力》指出：行为的懒惰充其量就是个懒人，思想和思维的懒惰者，却会成为一个不折不扣的庸人、废人。    当你想改变却只是做无效努力时，首先想想，你的思维和方向是否有误。    ![当你想改变却只是做无效努力时，首先想想，你的思维和方向是否有误。][1]    02      -----    日剧《人100%靠外表》，女主城之内纯是从事分析造纸素材的理科系女子，整日灰头土脸，和时尚无缘。    因为公司被收购，被分配到化妆品研发部工作。    而在随后的新年酒会上，因为穿着打扮太土，出了不少洋相。    羞愤之下，她决定出去找新工作，可因为觉得自己不好看肯定会求职失败，所以真的处处碰壁。    最后只好正视现实，和另外两个同事一起研究流行的化妆术。    虽然直到片尾，城之内纯也没有完美逆袭，但是她的精神状态完全不一样了。    她意识到，真正的问题不在于变得时尚，而是让自己变得自信，是勇于改变，更好地适应社会，而不是逃避，放弃自我。    ![她意识到，真正的问题不在于变得时尚，而是让自己变得自信，是勇于改变，更好地适应社会，而不是逃避，放弃自我。][2]    经济学上有个名词叫“路径依赖”，是指人们一旦做了某种选择，就好比走上了一条不归之路，惯性的力量会驱使其对这一路径产生依赖，并在相当程度上决定其现在和未来的选择。    其实，每个人都会产生路径依赖和惰性，在自己的舒适区安逸度日。    如果遭遇不顺，往往容易归结于外界的不友好，而不是反思自己是否在原地踏步。    过度依赖成功路径，是让人废掉的第一种思维。    遇到问题时，每个人都会参考以往的做法或者仿效他人。    一旦没有先例，没有成功经验可以借鉴，就无从下手。    日本作家日比野省三在《思维定式的“病”》一书里指出，**在瞬息万变的今天，变化成了家常便饭，没有先例可以依循。**    面对变化，如果不努力做出改进，就只是机械的重复，最终将停留于低层次的状态之下。    ![面对变化，如果不努力做出改进，就只是机械的重复，最终将停留于低层次的状态之下。][3]    03      -----    学妹立下flag，决定11点准时睡觉。    10点半躺床上刷手机酝酿睡意，把在追的小说更新的章节看完，又刷了一圈抖音、朋友圈和微博，批阅白天来不及看的信息。    期间，收到淘宝收藏商品做活动、今日头条关注作者更新的提示信息，又一一点进去看……一个晚上与手机难解难分。    第二天，学妹顶着黑眼圈说，熬夜伤身，所以直接通宵了。    信息爆炸的时代，每个人无时不刻都在接收信息。    大脑也像饕餮一般渴求更多信息，永不满足。    看起来，我们获取了更多的资讯和信息，但实际上，这类信息密度极低，往往“纤维”含量少而“脂肪”和“糖分”含量高，消费过量，只会让我们患上“信息肥胖症”，变得越来越浮躁，注意力涣散。    过度摄取这种低密度的信息，是让人废掉的第二种思维。    日比野省三也认为，**过量的信息，会导致大脑慢慢地产生疲劳，进而对重要的事情也变得麻木不仁。**    而要改善这个问题，就要像减肥一样，用节食方式选择摄取有营养的信息，排出占据大脑空间的垃圾信息。    对此，首先要做的，就是**减少刺激源**。    卸载不必要的软件，取关没营养的直播间、大V，关闭App推送通知。    在信息过载的时代，学会给大脑“断舍离”，删繁就简，隔绝多余信息。    只有过滤掉无用信息，才能把时间和精力用于获取真正为你所用的信息。    正如公关专家卡尼森说的，你不需要什么事情都关心，你只需要**关心对你有用的事物。    ![正如公关专家卡尼森说的，你不需要什么事情都关心，你只需要**关心对你有用的事物。][4]    04  --    《欢乐颂》里的樊胜美，活得精明而努力，工作十年触到了升职天花板。    编剧借安迪的内心独白指出问题所在：    安迪终于明白为什么樊胜美在上海这么多年，只能坐到那个位置，因为樊胜美是办公室的老油子。    表面上，樊胜美跟谁都处得来谁也不得罪，但是缺乏责任感，遇事永远先想着推卸责任，对工作的追求仅限于不出错，没有长远打算。    日比野省三说，不考虑长远的未来，缺乏规划的人，一旦遇到问题，就只是左冲右突地瞎蒙乱撞。    说到底，就是只顾眼前，只注重短期收获，而低估了长期付出带来的回报。    网友曾加这样形容这类人：**沉溺于轻易获得高成就感的事情**。有意无意地寻求用很小付出获得很大“回报”的偏方，哪怕回报是虚拟的。    比如，定下减肥计划，但因为难以坚持“管住嘴、迈开腿”，便寄望于各种减肥药；    想要读完某本书，但才翻了个开头就犯困，便想上网找精华解读或语音课程。    太急功近利，是让人废掉的第三种思维。    才刚开始行动，就希望看到立竿见影的效果，如果没有达到想要的结果，心态立马崩了，丧失了所有热情。    然而，世界上没有捷径，唯有脚踏实地，不急于求成，一点点努力，才能看到好的改变。    05  --    很多时候，我们假装已经足够努力，原谅自己偶尔的懒散懈怠，而忘记实在的努力，到头来感动的只有你自己。    > **如果很少感觉尽心竭力到无能为力的地步，那么，就谈不上努力。**    避免成为一个积极废人，积极的心态很重要，但更重要的是扎扎实实的努力。    选对方向，然后付出持续不断的努力，才是人生长路上的唯一正解。        [1]: https://i.w4ctech.cn/usr/uploads/2018/12/1906268422.jpg    [2]: https://i.w4ctech.cn/usr/uploads/2018/12/1553762152.jpg    [3]: https://i.w4ctech.cn/usr/uploads/2018/12/1289846194.jpg    [4]: https://i.w4ctech.cn/usr/uploads/2018/12/3927686090.jpg  那么爱立flag，你一定是积极废人吧.md  "},{title:"知乎短篇小说：救命,我被蜗牛追杀了！",path:"/posts/%E7%9F%A5%E4%B9%8E%E7%9F%AD%E7%AF%87%E5%B0%8F%E8%AF%B4%EF%BC%9A%E6%95%91%E5%91%BD,%E6%88%91%E8%A2%AB%E8%9C%97%E7%89%9B%E8%BF%BD%E6%9D%80%E4%BA%86%EF%BC%81.html",strippedContent:" 《救命，我被蜗牛追杀了》  ------------                      1.          说起来你可能不信，我被一只蜗牛追杀了。    故事还要从半年前说起。    那时候，我和陈沫刚分手，事业也处于低谷，还和父母大吵了一架。总之就是诸事不顺。    正当我准备以服安眠药自杀来结束这糟糕的人生时，奇迹般的事情发生了。    一个中性特征的陌生人出现在我的面前，对我说:“签订契约吗？”    我问他:“你是魔鬼吗？”    因为在我印象里，只有魔鬼才会用人的灵魂做交易。    陌生人说:“我的确是魔鬼，但我是来拯救你的。所以我是魔鬼中的天使。”    我放下手边的安眠药，疑惑地问:“那你要跟我签订什么契约？”    魔鬼中的天使说:“我要给你十亿美元。有了这么多钱，你可以挽回你的女朋友，可以用钱砸在上司的脸上，也可以让父母享受美好的晚年而不必再因为鸡毛蒜皮的事和你吵架。”    我想象起他所说的那副画面，不禁咽了咽口水。    “那么，代价呢？是灵魂吗？”    听到我的问题，魔鬼中的天使原本平淡的脸上，终于浮现出一丝淡淡的笑:“代价是你会被一只蜗牛追杀。至死方休。”    那时我还太年轻，不懂命运相赠的礼物，其实早已在暗中标好了价格。    我把手里的安眠药丢进垃圾桶，接过魔鬼中的天使递来的笔，毫不犹豫地写下了自己的名字。    “叶小白”。                2.          “契约已经签好了，那么十亿美元是现金给我呢还是打在我的账上？”    我期待地搓搓手。    魔鬼中的天使挥挥手，道:“现金。”    眨眼之间，狭小的出租房里一下子便成了钞票的海洋。    我扑在美元上，就像饥饿的人扑在面包上。    魔鬼中的天使又自顾自地说了些规则，最后，身形淡淡隐去。    我沉浸在一夜暴富的狂喜之中，兴奋想要打电话给陈沫，才突然记起我和她已经分手了，莫名的悲哀顿时涌上心头。    我又想打电话给父母，转念一想，我也已经搬出来住了，没这个必要。    就这样，我躺在钞票海洋里，血管里的热血一点点变凉。    我开始思考要怎么处理这些钱。    俗话说，鸡蛋不能放在一个篮子里，所以第一件事，就是购买了市面上最好的保险箱，将十亿美元分别装进十个箱子里。    不放银行，是我担心没有经济来源的我会被查，而我总不能说“这是魔鬼中的天使送我的”吧。    接着，我又雇佣了最好的保安团队，二十四小时照看保险箱和我本人的安全。    最后，我换上一身昂贵的西装，购置了两套豪宅，又买了数辆豪车。    做完这一切，已经是一个月之后了。    这期间，魔鬼中的天使隔三差五就会突然浮现在我的面前，提醒我说:“小心蜗牛。”    我不耐烦地说:“知道啦知道啦，碰到蜗牛就会死嘛！可是我住豪宅开跑车，怎么会有蜗牛嘛！”    春风得意的我，根本就听不进去半点与我不同的意见。    可是，当某一天深夜躺在床上休息时，我突然意识到了问题的严重性。    光滑干净的地板上，一只蜗牛正在缓缓地靠近我的床。准确来说，是靠近我的人。    它的爬行速度是如此之慢，让我产生一种毫无威胁的错觉。    我叫来卧室门前的保镖，指着地上的这只蜗牛，对他一顿臭骂。    （即便是夜里也要戴着墨镜的）保镖抬起他那纯黑作战靴，一脚踩下去。    我惊叫出声:“别弄脏了地板！”    保镖抬起脚。    地板上并不是一滩蜗牛壳的碎片和粘稠体液。    那只蜗牛还活着。    以缓慢的，不可阻挡的姿态，一点一点，向我爬行着。    我的心在一瞬间提到了嗓子眼。    魔鬼中的天使的话一下子浮现在我的耳边:“碰到蜗牛，你就会死。”    我吓软了腿，慌乱地倒退着爬了几步，就连后脑勺撞在墙上也没有察觉到疼。    在一只散发着死神气息的蜗牛面前，原本空旷而又华丽的卧室，竟然变成了让我无处可逃的牢笼。    我就要死了。    我心想。    十亿美元才到手一个月，连一个亿都没花出去，我就要死了。    我还没有去环游世界，还没有去挽回陈沫，还没有去羞辱上司，也还没有去找父母。    保镖叫来了他的的手下，企图用火烧锤砸等方式来杀死这只蜗牛，可是一3切都是无用功。    蜗牛没事，我的房子倒是被弄得一团糟。    当眼睁睁看着蜗牛爬上床上后，我只能绝望地闭上了眼。    反正本来也是要自杀的，多潇洒了这一个月，不说血赚之前也不亏了。    我在心里安慰这么自己。    保镖的叫声却打断了我的思路:“叶总，蜗牛不见了！”    我半信半疑地睁开眼。    伤痕累累的地板，挤满房间的保镖，什么都有，唯独没有那只蜗牛。    保镖挠了挠头:“奇怪，刚刚明明就在这里的，怎么突然不见了……难道是幻觉了？”    我摇摇头，拖着发软的双腿艰难挪到床边，指着地板上一道白色印痕说:“不是幻觉，那是蜗牛的爬行印记。”    保镖们不知道这是为什么，但我却心知肚明。    这只蜗牛每天零时会准时在我周围10公里范围随机刷新位置，刚刚一定是把它刷新到了其他地方。    所以今天我才能苟活。    可问题是。    今天把它从我身边刷到其他地方，可万一哪天把它从其他地方刷新到我的身边呢？    想到这，我不禁一阵恶寒。    十亿美元，多是多，就怕我没命花啊。                3.          渐渐的，我患上了神经衰弱。    一到夜里，我就坐立不安，非要保镖和清洁人员把家里翻个底朝天确保没有蜗牛的踪影。    甚至对任何形状类似蜗牛的物体都极度敏感。    所以当我在夜宵摊子找到陈沫时，几乎是立刻吓成了瘫痪，哪怕被两个保镖搀扶着，双腿也在不停地颤抖。    “你，你，你怎么在吃螺蛳？！”    陈沫诧异地抬起头，看向我，又扫了一眼我身旁的两个保镖。    片刻，她吐出了两个字:“您是？”    我又看了一眼她的对桌，是一个小鲜肉外形的男生。    我笑了。    推开保镖，打了一个响指，保镖便从停在路边的车里取出一个黑色箱子，在陈沫面前打开。    整整十万人民币。    我看见陈沫的眼神已经开始不由自主地往人民币上飘了。    小鲜肉的眼神也盯在了人民币上。    我说:“跟我走，这十万都归你。”    听到我的声音，陈沫才恍然醒悟，试探性地问:“你是……叶小白？”    接着，她又低语和小鲜肉解释，我是她的前男友。    小鲜肉的表情立马变得难堪了起来，看着周围的墨镜保镖，一时间如坐针毡。    陈沫沉思了片刻。    我当然知道她在沉思什么。    沉思过后，陈沫坚定地说:“我和董放的爱情不是金钱所能收买的！你走吧！我不会爱上你的！”    我不慌不忙，抬起手。    陈沫下意识地往后缩了缩脖子。她以为我要抽她。    其实我只是打了一个响指。    接着，又一个装满人民币的大箱子打开在我们的面前。    “一百万元整。”    保镖说完数额，我分明听到周围发出了阵阵倒吸凉气的声音。    我笑眯眯地望着陈沫。    陈沫的眼神没有之前那么坚定了。    她艰难地咬着嘴唇，眼神在一百万元和小鲜肉上飘忽不定。    小鲜肉缓缓抓住了她的手。    陈沫保持着沉默。    见状，我微笑着，又打了一个响指。    一千万元人民币，整整齐齐码在桌上。    全场寂静无声。    但我仿佛能听到围观群众咽口水以及胸膛里狂躁的心脏跳动的声音。    斗牛般骄傲的陈沫，终于像是被压垮了似的，缓缓低下头，小声地说:“我跟你走。”    小鲜肉的手，也被她打到一旁。    他们两个，一个人眼中黯淡无光，另一个人眼中却光芒涌动。    陈沫缓缓向我走近，像从前那样，站在我的右侧，并且试图牵住我的手。    我却绅士地抽出自己的手。    她诧异地看向我。    我笑着说:“我反悔了。”    吩咐保镖把一千一百万收回车上，只留下十万。    陈沫质问我:“叶小白，你这是什么意思？！”    我耸耸肩:“没什么意思。只是想告诉你的小男友，既然你会因为颜值离开前任，那么同样会因为钱而离开他。”    陈沫的脸上阴晴不定，胸口剧烈地起伏着。    她在看清了状况后，试图重新回到小鲜肉身旁，但小鲜肉却拒绝了她:“带着你的十万块钱，有多远滚多远吧。”    小鲜肉愤然离开。    我欣赏着眼前的这一幕，就差没有拍手叫好了。                4.          男人有钱就变坏，这句话说的一点都不错。    自从我有了十亿美元，身边接触的人事也都和以前不一样了，自然而然的，也就看不上曾经的女朋友陈沫了。    灯红酒绿，夜夜笙歌。    我不需要担心钱的问题，只需要担心怎么才能把钱花完。    以及另一个需要担心的问题:我该怎么才能活下去？    每一天蜗牛都会随机刷新位置，可常在河边走，哪有不湿鞋的？    终有一天我会死在这只死神蜗牛手里。    我要做的，是设法延迟这一天的到来。    因此，我也变得越来越焦躁，越来越不安。    我甚至怀疑所有人都对我图谋不轨。    医生说这叫被害妄想症。    我一拳揍在医生脸上，打碎他的眼镜，留下一句话:“以后见你一次打你一次。”    医生捂着脸，鲜血从指缝中流出。    “你怕了吗？我告诉你，我现在就和你一样！有只蜗牛也这样威胁我！见我一次杀我一次！你说说这算什么被害妄想症！”    医生想明白了，点点头说:“的确不是被害妄想症。被蜗牛威胁，我有个患者和你很像，他总觉得自己是个蘑菇，会被小姑娘摘走。所以你应该也是精神病。”                5.          渐渐的，我的失眠越来越严重了。    哪怕不是蜗牛刷新的时间，我也头痛欲裂，怎么都睡不着。    精神状况越来越差，每天都要摔家具才能略微缓解心中的烦闷。    浑浑噩噩的日子一过就是半年。    直到有一天。    当我打开保险箱时，才发现里面已经空了。    我淡定地关上柜门，又接连打开了几个保险箱。    脸上的笑容一点点消失不见。    我的十亿美元，已经所剩无几了。    零零散散的加在一起，估计也就只有一千万不到。    我定在原地，感觉自己呼吸困难。    遭了，这是心肌梗塞的感觉。    接着，我眼前一黑，直直地往后倒去。                6.          这半年来，我肆无忌惮地花钱，艺术品也买，奢侈品也买，半熟不熟的朋友来借钱也是一律不拒。    十亿美元，只出不进，就这样子花光了。    从医院病床醒来，我的第一句话是:“没钱好啊，没钱好啊。没钱我就只用担心蜗牛，而不用担心怎么花钱了。”    我妈伸手在我的眼前晃了晃:“说什么胡话呢？”    我定睛一看。    病床旁的，正是我那年迈的母亲。    她说:“没想到十亿美元这么快就花光了吧？”    我下意识地点点头。    两秒后，像个犯了错被发现的孩子那样，我又叫出了声:“妈，你咋知道十亿美元的事？！”    说话间，病房内的时间仿佛停滞了。    行走的护士们脚步逐渐变慢，最后完全定住。窗外的飞鸟也定格在了半空。    这时，我妈的脸一下子变成了一张中性特征的脸。    “怎么是你！魔鬼中的天使！”    魔鬼中的天使浮到半空，说:“我有个问题想问你。”    我点头。    他问:“既然你有挽回女朋友的能力，为什么没有去挽回她？”    我张张嘴，没有发出半点声音。    他又问:“既然你有足够的钱，为什么不像你之前说的那样让父母好好享福？”    我知道自己答不上来，干脆闭上了嘴。    魔鬼中的天使总结说:“你不回答，我也知道答案。因为人性是自私的。可惜了，我和天使中的魔鬼的赌，又输了。”    天使中的魔鬼？    赌约？    我有些摸不着头脑。    不过魔鬼中的天使也没有做更多的解释，只是说:“十亿美元已经被你花完了，从俭入奢易，从奢入俭难，你要是活着反而是生不如死。你能想象到的吧？”    我点点头，说:“的确。我现在就已经快被蜗牛折磨疯了。”    魔鬼中的天使第二次露出微笑。    他问:“那么，我们再签订一个契约吧。我给你一条全新的、永生不死的命，怎么样？”    我躺在病床上，苦笑道:“我还有别的选择吗？”                7.          我背起沉重的壳，象征着背负起我过去的罪恶。    我抛弃全身的骨头，象征着我丢下为人的尊严。    我成为了一只蜗牛，用尽一生来追逐那些追逐着金钱的人们。    只要能杀死他们，我就能解脱。    我并不知道哪一天才能解脱，但我知道，这一天一定会到来。    因为在这世上，眼睛里只有金钱的人数之不尽。    迟早有一天，他们都会死在我的手里。    又或是变成我的同类。          "},{title:"知乎高赞：一个人是怎么一步一步废掉的？",path:"/posts/%E7%9F%A5%E4%B9%8E%E9%AB%98%E8%B5%9E%EF%BC%9A%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%98%AF%E6%80%8E%E4%B9%88%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%BA%9F%E6%8E%89%E7%9A%84%EF%BC%9F.html",strippedContent:" 1. **沉溺于「轻易获得高成就感」的事情**      有意无意地寻求用很小付出获得很大「回报」的偏方，哪怕回报是虚拟的。这种行为会提升自己的「兴奋阈值」，让人越来越不容易拥有成就感，从而越来越依赖虚拟的成就感，陷入恶性循环。      症状轻的：沉溺游戏（在虚拟世界中加快时间流逝的速度，使得「成功」来得更快）、种马小说（意淫人能轻易获得想要的东西）；症状重甚至犯法的：赌博（轻易获得「金钱」）、吸毒（轻易获得「爽」的感觉）等。     2. **只接收「低信息密度」的信息源**      只愿意接收信息密度低的信息（如无需太多动脑的视频、图片，以及深度较浅的娱乐、八卦、体育新闻等），不愿意接收信息密度高、需要思考后才能吸收的信息（如课程、知识框架、分析报告等）。      由于真正有价值、能让人进步的信息大多是需要思考和消化的，所以如果完全隔离了这部分内容，基本也就隔离了进步的可能。     3. **习惯用「错位成就感」麻痹自己**      有两类：① 习惯于拿自己擅长的东西和别人不擅长的东西比较，从来获得「比别人强」的错觉（如：和运动员比学习成绩，和学霸比体育）；      ② 习惯于拿别人做事情 A 的时间来做事情 B，来假装自己在事情 B 上做得好（如：「炫耀」自己在节假日做了比别人更多的工作，但也仅仅是在节假日才能如此）。     4. **过度依赖「既有可行路径」**      在工作中，习惯了一件事情的流程后再也没想过如何改进，只会机械地重复，然后骗自己很充实。      没有改进，便也没有剔除糟粕的意识，于是需要重复的东西越来越多，消耗时间也越来越长，到最后，看上去每天做了很多事情，但其实不仅一点进步都没有，还挤占了进步的空间。     5. **封闭「强化学习」的通道**      在学习或接受信息中，只愿意执行最简单的第一步，却不愿意执行接下来更为复杂的巩固和应用流程，只听不说、只看不写、只学不练，还麻痹自己说学到了很多东西，而实际上，这种「浅层」的学习遗忘极快，有时还不如不学。  比如，天天学英语，却从不写英语文章；再比如，天天花大量时间刷知乎，却从不写答案、写总结。    "},{title:"简书高赞：毁掉你们的不是抖音，而是你自己！",path:"/posts/%E7%AE%80%E4%B9%A6%E9%AB%98%E8%B5%9E%EF%BC%9A%E6%AF%81%E6%8E%89%E4%BD%A0%E4%BB%AC%E7%9A%84%E4%B8%8D%E6%98%AF%E6%8A%96%E9%9F%B3%EF%BC%8C%E8%80%8C%E6%98%AF%E4%BD%A0%E8%87%AA%E5%B7%B1.html",strippedContent:' &ensp;&ensp;&ensp;&ensp;旅游圈仿佛有一个隐藏的定律——  &ensp;&ensp;&ensp;&ensp;**＂哪里火哪里就会被破坏＂**  &ensp;&ensp;&ensp;&ensp;玉龙雪山火了，慢慢变成了秃山；茶卡盐湖火了，不久就变成了垃圾场；西藏朝圣火了，去往西藏的路于是就成了肮脏之路。  &ensp;&ensp;&ensp;&ensp;果不其然。  &ensp;&ensp;&ensp;&ensp;抖音爆红的网红花海终于还是被人毁了。  &ensp;&ensp;&ensp;&ensp;![抖音爆红的网红花海终于还是被人毁了。][1]    &ensp;&ensp;&ensp;&ensp;来这里＂参观＂的各路朋友，为了找好角度拍出美美的照片和视频。    &ensp;&ensp;&ensp;&ensp;基本都对花海周围的围栏选择了无视，直接踩踏或者躺在植物当中拍摄。  &ensp;&ensp;&ensp;&ensp;![基本都对花海周围的围栏选择了无视，直接踩踏或者躺在植物当中拍摄。][2]    &ensp;&ensp;&ensp;&ensp;**鲁迅说:"世上本没有路，走的人多了也便有了路。"**    &ensp;&ensp;&ensp;&ensp;可是花海的路不只是人们踩出来的。    &ensp;&ensp;&ensp;&ensp;为了拍出想要的效果，人们甚至还把周围多余的草放倒压实，以此制造出更大的空间。拍照的人们是玩儿嗨了。    &ensp;&ensp;&ensp;&ensp;可是苦心管理着这片花海的郑阿姨却哭成了泪人。    &ensp;&ensp;&ensp;&ensp;她说的一句话听起来非常沉重：    **&ensp;&ensp;&ensp;&ensp;你们拍照片的人，拍出来的照片很美，可是你们的行为却很难看。**    &ensp;&ensp;&ensp;&ensp;![你们拍照片的人，拍出来的照片很美，可是你们的行为却很难看。][3]            &ensp;&ensp;&ensp;&ensp;本来是这样的剧情，偏偏又出来一大票网络大军开始diss抖音。  &ensp;&ensp;&ensp;&ensp;不能不承认，恶俗搞怪、拜金炫富、私奔堕胎、少女产子、擦边色情······  &ensp;&ensp;&ensp;&ensp;这些现象的出现，各大短视频平台监管不力确实难逃其咎。    &ensp;&ensp;&ensp;&ensp;![这些现象的出现，各大短视频平台监管不力确实难逃其咎。][4]        &ensp;&ensp;&ensp;&ensp;而花海这种因为爆红而惨遭破坏的现象，也要归咎于某短视频平台的做法实在是有些＂睿智＂。    &ensp;&ensp;&ensp;&ensp;毕竟除了这些负面的东西，我还在各大短视频app看到了不少有用的东西。    &ensp;&ensp;&ensp;&ensp;我见到过详细的做饭教程。    &ensp;&ensp;&ensp;&ensp;哪怕你是和老史一样的小白，按照视频的步骤也能做出一份让自己刮目相看的菜品。    &ensp;&ensp;&ensp;&ensp;我见过各种手工diy，也见过分享各种软件的使用技巧，见过各种精彩的片段，见过非常深刻的内容，还见过很多非常搞笑的段子。    &ensp;&ensp;&ensp;&ensp;这些都是非常积极的东西，也都得益于一些平台的便利条件。    &ensp;&ensp;&ensp;&ensp;![这些都是非常积极的东西，也都得益于一些平台的便利条件。][5]        &ensp;&ensp;&ensp;&ensp;与这些相反的，老史也见过很多内容肤浅，三观奇歪，甚至是毫无下限的内容。    &ensp;&ensp;&ensp;&ensp;可讽刺的是，浏览量高，点赞量大的恰恰是那些既不是原创又没有营养的类型。    &ensp;&ensp;&ensp;&ensp;这真的全是平台的错吗？    **&ensp;&ensp;&ensp;&ensp;错的不是平台，而是使用平台的人。**    &ensp;&ensp;&ensp;&ensp;前段时间给大家推荐过一部很好看的科幻片——**「升级」**    &ensp;&ensp;&ensp;&ensp;科学家艾伦发明了具有超强运算能力和处理信息能力外加支配身体能力的＂智脑＂。    &ensp;&ensp;&ensp;&ensp;可是他贪图智脑的快捷与方便，以至于智脑一步一步完全占据了他的身体支配权。            &ensp;&ensp;&ensp;&ensp;走上同样路子的还有主角格雷。    &ensp;&ensp;&ensp;&ensp;本来他是因为被已经完全控制艾伦的智脑设计而瘫痪。    &ensp;&ensp;&ensp;&ensp;在使用智脑重新站起来后，却因为自己的贪婪也被智脑完全操纵。            &ensp;&ensp;&ensp;&ensp;任何事物都必然有它的双面性。    &ensp;&ensp;&ensp;&ensp;哪怕是吃饭这么简单的事情，不按时不定量不注意搭配都有可能出现肥胖的负面情况。    &ensp;&ensp;&ensp;&ensp;何况是千千万万个不同思想同时使用的视频平台呢？      &ensp;&ensp;&ensp;&ensp;![何况是千千万万个不同思想同时使用的视频平台呢？][6]      &ensp;&ensp;&ensp;&ensp;短视频平台应该加强监管，而作为使用者的我们更要管好自己。    &ensp;&ensp;&ensp;&ensp;在花海遭到破坏的时候，有记者尝试过前去劝阻，也曾询问过人们是否知道这里不允许进入围栏拍照。    &ensp;&ensp;&ensp;&ensp;一部分假装没听到，而大部分人则表示：    **&ensp;&ensp;&ensp;&ensp;我拍一张就走。**    &ensp;&ensp;&ensp;&ensp;好像在得到主人的原谅之前，他们就已经提前原谅了自己。    &ensp;&ensp;&ensp;&ensp;还记得「密阳」中的一个情节。    &ensp;&ensp;&ensp;&ensp;女主申爱的儿子被觊觎她钱财的校长绑架并且撕票。    &ensp;&ensp;&ensp;&ensp;虽然校长很快被抓，申爱还是陷入了长时间的自责和沉沦当中。    &ensp;&ensp;&ensp;&ensp;终于有一天，她鼓起勇气去监狱探望校长，希望和以前种种一笔勾销重新开始。    &ensp;&ensp;&ensp;&ensp;结果怎么着？    &ensp;&ensp;&ensp;&ensp;校长红光满面心态平和，原来在申爱选择原谅他之前，他早已经原谅了自己。      &ensp;&ensp;&ensp;&ensp;![校长红光满面心态平和，原来在申爱选择原谅他之前，他早已经原谅了自己。][7]      &ensp;&ensp;&ensp;&ensp;对于别人犯下的错误，我们总是习惯揪住不放，而对于自己犯下的错误却习惯自我原谅。    &ensp;&ensp;&ensp;&ensp;就像踩踏破坏花海的人们。    &ensp;&ensp;&ensp;&ensp;在平时的生活中，也许就有他/她们严格管束身边人的曾经。    &ensp;&ensp;&ensp;&ensp;在某篇文章亦或是某个视频的评论处，也许就有他/她们针砭时弊义愤填膺的点评痕迹。    &ensp;&ensp;&ensp;&ensp;请各位在指点江山挥斥方遒之时，多一些理智，少一些盲目。    &ensp;&ensp;&ensp;&ensp;如果像这位老哥一样，一个不小心留下了这种评论岂不是让人笑掉大牙？    &ensp;&ensp;&ensp;&ensp;人家澳大利亚进口的植物，怎么就成了某老家土生土长大片大片的了？    &ensp;&ensp;&ensp;&ensp;你以为是你老家的芦苇杆吗？    &ensp;&ensp;&ensp;&ensp;这个锅老家可不替你背。    &ensp;&ensp;&ensp;&ensp;在这个流量至上的时代，短视频的出现几乎是历史发展的必然。    &ensp;&ensp;&ensp;&ensp;就算是没有抖音、火山、快手也会有千千万万个跳音、蹦音、冰山、雪山、高手、低手、咸猪手出现。    &ensp;&ensp;&ensp;&ensp;大部分错误不在视频平台，而在于那些趋之若鹜的人们不能理智地面对。    &ensp;&ensp;&ensp;&ensp;曾经有大人带着自家孩子模仿视频中的动作，因为出现差错，导致孩子脊髓眼中受损，上半身无法行动，    &ensp;&ensp;&ensp;&ensp;就连医生都无法预料恢复时间。    &ensp;&ensp;&ensp;&ensp;还有很多大人在门上拉上透明胶布，来观察孩子的反应。    &ensp;&ensp;&ensp;&ensp;无论是宠物还是小孩儿，都成为了那些心智成熟的成年人手中的＂娱乐工具＂。    &ensp;&ensp;&ensp;&ensp;这到底是谁的错？      &ensp;&ensp;&ensp;&ensp;![这到底是谁的错？][8]      &ensp;&ensp;&ensp;&ensp;遇事甩锅，是非常非常无知的巨婴行径。    &ensp;&ensp;&ensp;&ensp;禁抖音、禁快手、禁火山？幼稚！    &ensp;&ensp;&ensp;&ensp;这不过是一些治标不治本的小把戏罢了。    &ensp;&ensp;&ensp;&ensp;低素质到那里都会是低素质中的一员。    &ensp;&ensp;&ensp;&ensp;原罪在于那些没有素质的人，也在于那些无脑追捧助纣为虐的人。    &ensp;&ensp;&ensp;&ensp;吕氏春秋有一句话很好：    &ensp;&ensp;&ensp;&ensp;王者乐其所以王，亡者亦乐其所以亡。    &ensp;&ensp;&ensp;&ensp;你喜爱的事物，正决定着你将会成为什么样的人。        &ensp;&ensp;&ensp;&ensp;![你喜爱的事物，正决定着你将会成为什么样的人。][9]    &ensp;&ensp;&ensp;&ensp;做好自己管好自己，做一个有头脑，有素质，不跟风的人。    &ensp;&ensp;&ensp;&ensp;别光顾着表面上好看。    &ensp;&ensp;&ensp;&ensp;人们拍好看的照片不就是为了给自己留念，为了给其他人留念？    &ensp;&ensp;&ensp;&ensp;可如果留念的背后是让人唾弃和鄙视的行为，结果可能比你想象的要严重。    &ensp;&ensp;&ensp;&ensp;不信你看。    &ensp;&ensp;&ensp;&ensp;慈禧可是当时少有的，有便利照相条件的人。    &ensp;&ensp;&ensp;&ensp;也是非常少有的，可以有机会拍出美照的一类。    &ensp;&ensp;&ensp;&ensp;可是她拍出的照片留到现在，最多就是方便了现代人对着她的形象骂她而已。    &ensp;&ensp;&ensp;&ensp;别无它用。        [1]: https://upload-images.jianshu.io/upload_images/7994685-d558b9e459cd9571.jpeg?imageMogr2/auto-orient/    [2]: https://upload-images.jianshu.io/upload_images/7994685-e928b1d3981c3e12.jpeg?imageMogr2/auto-orient/    [3]: https://upload-images.jianshu.io/upload_images/7994685-162f4da8c85402d0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp    [4]: https://upload-images.jianshu.io/upload_images/7994685-010ada6062fc543e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp    [5]: https://upload-images.jianshu.io/upload_images/7994685-c4c4b2b4f2ab2729.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/474/format/webp    [6]: https://upload-images.jianshu.io/upload_images/7994685-dfb21ee024fae549.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp    [7]: https://upload-images.jianshu.io/upload_images/7994685-899fce35361eed0c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp    [8]: https://upload-images.jianshu.io/upload_images/7994685-9a17edd118a5d135.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/394/format/webp    [9]: https://upload-images.jianshu.io/upload_images/7994685-209b2974b7762a60.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp  '},{title:"linux命令笔记",path:"/posts/linux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0.html",strippedContent:' 1. cd类 （切换目录）     - ``cd dirName`` 语法     - ``cd ~`` 切换到home目录     - ``cd ../..`` 切换到目录的上两层  2. ls   （显示目录）     - ``ls [-alrtAFR] [name...]`` 语法                  ```           -a 显示所有文件及目录 (ls内定将文件名或目录名称开头为"."的视为隐藏档，不会列出)          -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出          -r 将文件以相反次序显示(原定依英文字母次序)          -t 将文件依建立时间之先后次序列出          -A 同 -a ，但不列出 "." (目前目录) 及 ".." (父目录)          -F 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"          -R 若目录下有文件，则以下之文件亦皆依序列出\\        ```     - ``ls /`` 列出根目录下的所有目录     ![ls /](https://s1.ax2x.com/2018/10/16/5TeydK.png)     - ``ls -ltr l*``  按照建立时间将当期目录下以l开头的文件列出    '},{title:"kali linux下安装搜狗输入法",path:"/posts/kali%20linux%E4%B8%8B%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95.html",strippedContent:" 一.更新源：   1. 终端中输入：``leafpad /etc/apt/sources.list`` 进入``sources.list``文件。  2. 修改``sources.list``文件源保存并退出：          ```          #kali官方源          deb http://http.kali.org/kali kali-rolling main non-free contrib          #中科大的源          deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib          deb http://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-free          deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-free          deb http://mirrors.ustc.edu.cn/kali-security kali-current/updates main contrib non-free          deb-src http://mirrors.ustc.edu.cn/kali-security kali-current/updates main contrib non-free          #阿里云源          deb http://mirrors.aliyun.com/kali sana main non-free contrib          deb http://mirrors.aliyun.com/kali-security/ sana/updates main contrib non-free          deb-src http://mirrors.aliyun.com/kali-security/ sana/updates main contrib non-free          #          deb http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu xenial main          ```  3. 更新源``apt-get update``  4. 安装fcitx:``apt-get install fcitx``  5. 安装fcitx-libs-qt ``apt-get install fcitx-libs-qt``    二.安装搜狗输入法   1. 在[http://pinyin.sogou.com/linux/](http://pinyin.sogou.com/linux/)中下载对应版本号的搜狗输入法   2. 安装搜狗输入法      - .进入下载目录``cd ~/下载/ ``     - .安装 ``dpkg -i sogo安装包文件名``    三. 启用搜狗输入法   1. 终端输入``im-config``   2. 进入输入法配置，选择确定点击是，在弹出来的输入法选择框中选择fcitx，然后确定。   3. 注销账号，重新登录，然后右上角有个键盘图标，点击选择【设置】，在左下角点击【+】新增输入法 ；在弹出窗口中取消“仅显示当前预览”复选框，然后搜索Sogou,找到搜狗输入法，点击OK  "},{title:"欢迎使用 Typecho",path:"/posts/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8%20Typecho.html",strippedContent:"如果您看到这篇文章,表示您的 blog 已经安装成功.  "}]}}]);